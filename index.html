<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />

    <!-- BEGIN Info -->
    <meta
      name="description"
      content="Nexus is an open-source GraphQL framework that generates an instant GraphQL server from a user's existing data sources and automates deployment to AWS."
    />
    <meta name="title" property="og:title" content="Nexus" />
    <meta property="og:type" content="Website" />
    <meta name="image" property="og:image" content="assets/nexus-logo.png" />
    <meta
      name="description"
      property="og:description"
      content="Nexus - Nexus is an open-source GraphQL framework that generates an instant GraphQL server from a user's existing data sources and automates deployment to AWS."
    />
    <meta name="author" content="Nexus" />
    <!-- END Info -->

    <!-- BEGIN favicon -->
    <link
      rel="apple-touch-icon"
      sizes="180x180"
      href="assets/favicon/apple-touch-icon.png"
    />
    <link
      rel="mask-icon"
      href="assets/favicon/safari-pinned-tab.svg"
      color="#5bbad5"
    />
    <link rel="shortcut icon" href="assets/favicon/favicon.ico" />
    <meta name="msapplication-TileColor" content="#ffffff" />
    <meta
      name="msapplication-config"
      content="images/favicon/browserconfig.xml"
    />
    <meta name="theme-color" content="#ffffff" />
    <!-- END favicon -->

    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Nexus</title>

    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css"
    />
    <link
      rel="stylesheet"
      href="https://unpkg.com/@tailwindcss/typography@0.2.x/dist/typography.min.css"
    />
    <link rel="stylesheet" href="stylesheets/reset.css" />
    <link rel="stylesheet" href="stylesheets/style.css" />
    <link rel="stylesheet" href="stylesheets/responsive.css" />
  </head>
  <body>
    <header class="mobile-menu-closed">
      <div id="header">
        <a href="./index.html">
          <img src="assets/logo/main-logo.png" />
        </a>
        <nav>
          <a href="#start-here" class="selected">Overview</a>
          <a href="#case-study">Case Study</a>
          <a href="#presentation">Presentation</a>
          <a href="#our-team">The Team</a>
          <a
            href="https://github.com/nexus-graphql"
            target="_blank"
            class="icon"
            ><i class="fab fa-github"></i
          ></a>
        </nav>
        <div id="menu">
          <button type="button">
            <svg
              id="mobile-open"
              xmlns="http://www.w3.org/2000/svg"
              fill="none"
              viewBox="0 0 24 24"
              stroke="currentColor"
              aria-hidden="true"
            >
              <path
                stroke-linecap="round"
                stroke-linejoin="round"
                stroke-width="2"
                d="M4 6h16M4 12h16M4 18h16"
              />
            </svg>
            <svg
              id="mobile-close"
              xmlns="http://www.w3.org/2000/svg"
              fill="none"
              viewBox="0 0 24 24"
              stroke="currentColor"
              aria-hidden="true"
            >
              <path
                stroke-linecap="round"
                stroke-linejoin="round"
                stroke-width="2"
                d="M6 18L18 6M6 6l12 12"
              />
            </svg>
          </button>
        </div>
      </div>

      <div id="header-buffer"></div>

      <div id="mobile-menu">
        <a href="#start-here" class="selected">Overview</a>
        <a href="#case-study">Case Study</a>
        <a href="#presentation">Presentation</a>
        <a href="#our-team">Our Team</a>
        <a href="https://github.com/nexus-graphql" target="_blank"
          ><i class="fab fa-github"></i></a>
      </div>
    </header>


    <div id="start-here" class="main-section">
      <div class="h-full">
        <div class="static-logo-color"></div>
        <div class="">
          <img
            class="nexus sm-screen"
            src="assets/logo/nexus-logo.png"
          />
          <img class="nexus lg-screen" src="assets/logo/nexus-name.png" />

          <p class="light-text">
            An open-source framework that<br />generates an instant
            <span class="text-pink">GraphQL server</span><br /> from
            <span class="text-blue">multiple data sources</span><br />
          </p>
        </div>
      </div>

      <div class="h-full">
        <div class="bg-dark-blue static-logo-blue">
          <h2>Instant GraphQL Server</h2>
        </div>
        <div class="bg-dark-blue">
          <h2 class="sm-header">Instant GraphQL Server from Nexus</h2>
          <p>A GraphQL server will be automatically generated from a user's existing Postgres database</p>
          <img class="nexus lg-screen" src="assets/media/images/server.png" />
        </div>
      </div>

      <div class="h-full">
        <div class="bg-pink static-logo-white">
          <h2>Test The Server Locally</h2>
        </div>
        <div class="bg-pink">
          <h2 class="sm-header">Test The Server Locally</h2>
          <p>
            Test the generated GraphQL server locally with an integrated graphical interface
          </p>
          <img src="assets/media/images/graphical.png"/>
        </div>
      </div>
      
      <div class="h-full">
        <div class="bg-dark-blue static-logo-blue">
          <h2>Easy to Deploy</h2>
        </div>
        <div class="bg-dark-blue">
          <h2 class="sm-header">Easy to Deploy</h2>
          <p>
            Use Nexus's CLI to deploy all the necessary infrastructure 
            to Amazon Web Services (AWS) with a single command</p>
            <img src="assets/media/images/architecture.png"/>
        </div>
      </div>
      
    </div>

    <aside id="toc">
      <!-- Case Study <br /><br /> -->
      <ul>
        <!-- Section 1 -->
        <li data-section="section-1" class="selected">
          <a href="#section-1">
            <div>
              <div class="bullet"><div></div></div>
              <p>1. What is Nexus?</p>
            </div>
          </a>
        </li>

        <!-- Section 2 -->
        <li data-section="section-2">
          <a href="#section-2">
            <div>
              <div class="bullet"><div></div></div>
              <p>2. APIs</p>
            </div>
          </a>
        </li>
        <li data-section="section-2" class="subitem">
          <a href="#section-2-1">
            <div>
              <div class="bullet"><div></div></div>
              <p>2.1 REST</p>
            </div>
          </a>
        </li>
        <li data-section="section-2" class="subitem">
          <a href="#section-2-2">
            <div>
              <div class="bullet"><div></div></div>
              <p>2.2 Under-fetching and Over-fetching Data</p>
            </div>
          </a>
        </li>
        <li data-section="section-2" class="subitem">
          <a href="#section-2-3">
            <div>
              <div class="bullet"><div></div></div>
              <p>2.3 Adapting an API</p>
            </div>
          </a>
        </li>

        <!-- Section 3 -->
        <li data-section="section-3">
          <a href="#section-3">
            <div>
              <div class="bullet"><div></div></div>
              <p>3. GraphQL</p>
            </div>
          </a>
        </li>
        <li data-section="section-3" class="subitem">
          <a href="#section-3-1">
            <div>
              <div class="bullet"><div></div></div>
              <p>3.1 GraphQL Implementation Challenges</p>
            </div>
          </a>
        </li>
        <li data-section="section-3" class="subitem">
          <a href="#section-3-2">
            <div>
              <div class="bullet"><div></div></div>
              <p>3.2 Server Components</p>
            </div>
          </a>
        </li>
        <li data-section="section-3" class="subitem">
          <a href="#section-3-3">
            <div>
              <div class="bullet"><div></div></div>
              <p>3.3 Schema Writing Approaches</p>
            </div>
          </a>
        </li>
        <li data-section="section-3" class="subitem">
          <a href="#section-3-4">
            <div>
              <div class="bullet"><div></div></div>
              <p>3.4 Deployment</p>
            </div>
          </a>
        </li>

        <!-- Section 4 -->
        <li data-section="section-4">
          <a href="#section-4">
            <div>
              <div class="bullet"><div></div></div>
              <p>4. Existing Solutions</p>
            </div>
          </a>
        </li>
        <li data-section="section-4" class="subitem">
          <a href="#section-4-1">
            <div>
              <div class="bullet"><div></div></div>
              <p>4.1 Managed Cloud Services</p>
            </div>
          </a>
        </li>
        <li data-section="section-4" class="subitem">
          <a href="#section-4-2">
            <div>
              <div class="bullet"><div></div></div>
              <p>4.2 Open Source Libraries</p>
            </div>
          </a>
        </li>
        <li data-section="section-4" class="subitem">
          <a href="#section-4-3">
            <div>
              <div class="bullet"><div></div></div>
              <p>4.3 Nexus</p>
            </div>
          </a>
        </li>

        <!-- Section 5 -->
        <li data-section="section-5">
          <a href="#section-5">
            <div>
              <div class="bullet"><div></div></div>
              <p>5. Nexus Walkthrough</p>
            </div>
          </a>
        </li>
        <li data-section="section-5" class="subitem">
          <a href="#section-5-1">
            <div>
              <div class="bullet"><div></div></div>
              <p>5.1 Download and Setup</p>
            </div>
          </a>
        </li>
        <li data-section="section-5" class="subitem">
          <a href="#section-5-2">
            <div>
              <div class="bullet"><div></div></div>
              <p>5.2 Initializing GraphQL API Server</p>
            </div>
          </a>
        </li>
        <li data-section="section-5" class="subitem">
          <a href="#section-5-3">
            <div>
              <div class="bullet"><div></div></div>
              <p>5.3 Adding Other Data Sources</p>
            </div>
          </a>
        </li>
        <li data-section="section-5" class="subitem">
          <a href="#section-5-4">
            <div>
              <div class="bullet"><div></div></div>
              <p>5.4 Testing the Server</p>
            </div>
          </a>
        </li>
        <li data-section="section-5" class="subitem">
          <a href="#section-5-5">
            <div>
              <div class="bullet"><div></div></div>
              <p>5.5 Deployment</p>
            </div>
          </a>
        </li>
        <li data-section="section-5" class="subitem">
          <a href="#section-5-6">
            <div>
              <div class="bullet"><div></div></div>
              <p>5.6 Dashboard</p>
            </div>
          </a>
        </li>
        <li data-section="section-5" class="subitem">
          <a href="#section-5-7">
            <div>
              <div class="bullet"><div></div></div>
              <p>5.7 Destroy</p>
            </div>
          </a>
        </li>

        <!-- Section 6 -->
        <li data-section="section-6">
          <a href="#section-6">
            <div>
              <div class="bullet"><div></div></div>
              <p>6. Nexus Architecture</p>
            </div>
          </a>
        </li>
        <li data-section="section-6" class="subitem">
          <a href="#section-6-1">
            <div>
              <div class="bullet"><div></div></div>
              <p>6.1 Generating the Server</p>
            </div>
          </a>
        </li>
        <li data-section="section-6" class="subitem">
          <a href="#section-6-1-1">
            <div>
              <div class="bullet"><div></div></div>
              <p>6.1.1 Initializing the Server and Integrating Data Sources</p>
            </div>
          </a>
        </li>
        <li data-section="section-6" class="subitem">
          <a href="#section-6-2">
            <div>
              <div class="bullet"><div></div></div>
              <p>6.2 Deploying the Server</p>
            </div>
          </a>
        </li>

        <li data-section="section-7">
          <a href="#section-7">
            <div>
              <div class="bullet"><div></div></div>
              <p>7. Nexus Implementation Challenges</p>
            </div>
          </a>
        </li>
        <li data-section="section-7" class="subitem">
          <a href="#section-7-1">
            <div>
              <div class="bullet"><div></div></div>
              <p>7.1 Connecting Multiple Data Sources</p>
            </div>
          </a>
        </li>
        <li data-section="section-7" class="subitem">
          <a href="#section-7-2">
            <div>
              <div class="bullet"><div></div></div>
              <p>7.2 Hot Reloading</p>
            </div>
          </a>
        </li>
        <li data-section="section-7" class="subitem">
          <a href="#section-7-3">
            <div>
              <div class="bullet"><div></div></div>
              <p>7.3 Time to Redeploy</p>
            </div>
          </a>
        </li>

        <!-- Section 8 -->
        <li data-section="section-8">
          <a href="#section-8">
            <div>
              <div class="bullet"><div></div></div>
              <p>8. Future Work</p>
            </div>
          </a>
        </li>
        <li data-section="section-8" class="subitem">
          <a href="#section-8-1">
            <div>
              <div class="bullet"><div></div></div>
              <p>8.1 Customization of the GraphQL Schema</p>
            </div>
          </a>
        </li>
        <li data-section="section-8" class="subitem">
          <a href="#section-8-2">
            <div>
              <div class="bullet"><div></div></div>
              <p>8.2 Multi-Cloud Deployment</p>
            </div>
          </a>
        </li>
        <li data-section="section-8" class="subitem">
          <a href="#section-8-3">
            <div>
              <div class="bullet"><div></div></div>
              <p>8.3 Allowing Additional Data Sources</p>
            </div>
          </a>
        </li>
      </ul>
    </aside>

    <div id="case-study" class="main-section">
      <div id="case-study-content">
        <div class="prose">         
          <h1>Case Study</h1>

          <!-- Section 1 -->
          <h2 id="section-1">1. What is Nexus?</h2>

          <figure>
            <img src="assets/media/diagrams/1.png" class="case-study-image" />
            <figcaption>Fig.1 - Nexus is an instant GraphQL API framework</figcaption>
          </figure>

          <p>
            Nexus is an open-source framework that generates and deploys a GraphQL API from a user’s existing data sources. We simplify the user's setup by providing a CLI tool and admin dashboard. Data sources can be added, removed, and changed without writing any new code or schemas. Additionally, users can test the generated GraphQL API locally with an integrated graphical interface. This interface exposes the API’s documentation and serves as a playground for making test queries and viewing responses. Finally, when the API is ready to deploy, Nexus automates deployment to AWS.
          </p>

          <p>
            In this case study, we will introduce APIs, GraphQL, and the challenges developers face when implementing GraphQL APIs. Furthermore, we discuss how and why Nexus was built and the features we hope to develop in the future. The main goal of Nexus was to efficiently deploy an auto-generated GraphQL server that connects to multiple data sources. Before diving deeper into Nexus, let’s discuss what an API is and how it can be used.
          </p>
  
          <!-- Section 2 -->
          <h2 id="section-2" class="h2">2. APIs</h2>

          <p>
            An API, or Application Programming Interface, is a way to share data across different systems. This is similar to how a mouse, keyboard, or screen is used as an interface to transfer data between humans and computers. An API is a layer that standardizes and abstracts the inner workings of two separate systems, allowing them to communicate fluidly. An API is a layer that standardizes and abstracts the inner workings of two separate systems, allowing them to communicate fluidly.
          </p>

          <figure>
            <img src="assets/media/diagrams/2.png" class="case-study-image" />
            <figcaption>Fig.2 - APIs are a way to share data across systems</figcaption>
          </figure>
  
          <p>
            Web applications are commonly split into two major parts: the “frontend” and the “backend." These parts are decoupled to separate concerns. The frontend handles how a web page looks and user interaction with the page. In contrast, the backend accesses databases and handles business logic. The development workflow is optimized by decoupling, allowing separate languages, libraries, and frameworks to be used.
          </p>

          <p>
            Once separated, the two parts need a common language to communicate with each other. An API serves as the link, allowing communication in a standardized format. Many API patterns and conventions specify how to build and design APIs for different needs. Many of them are endpoint-based, and the most common is REST.
          </p>

          <h3 id="section-2-1">2.1 REST</h3>

          <p>
            A RESTful API provides endpoints corresponding to the application's significant resources. REST utilizes the HTTP protocol to define actions that can be taken on those resources via HTTP methods. Following REST conventions, the API is standardized, typically allowing the user to infer an endpoint's intention. For example, sending a GET request to a <span class="code-snippet">/books</span> endpoint would send back information on all books, whereas a GET request to <span class="code-snippet">/books/:id</span> would send back information about a specific book.
          </p>

          <figure>
            <img src="assets/media/diagrams/3.png" class="case-study-image" />
            <figcaption>Fig.3 - Example of REST API endpoints</figcaption>
          </figure>
  
          <p>
            REST has become the dominant pattern for building web application APIs. By some estimates, over 89% of APIs today follow REST conventions. One reason for its popularity is that REST is simple for developers to understand and build. It interacts well with other building blocks of web architecture, like the HTTP protocol. REST particularly shines in applications where client pages correspond directly with REST endpoints. 
          </p>

          <figure>
            <img src="assets/media/diagrams/4.png" class="case-study-image" />
          </figure>

          <p>
            Although REST has many benefits, issues can arise when a new frontend use case is integrated with an existing REST API. Consider a hypothetical bookstore, a web application supported by a REST API. When a new mobile application is introduced, a few problems become more prevalent.
          </p>

          <h3 id="section-2-2">2.2 Under-fetching and Over-fetching Data</h3>

          <p>
            Due to a mobile device's limited screen size, fewer book details can be displayed on the catalog screen, and therefore less data is needed from the API to load this page. Figure 4 illustrates this difference in design between the desktop and mobile applications. Details such as publisher, publish date, and format are not part of the mobile application’s catalog page.
          </p>

          <figure>
            <img src="assets/media/diagrams/5.png" class="case-study-image" />
            <figcaption>Fig.4 - Each client type has different data needs.</figcaption>
          </figure>

          <p>
            When the frontend developer fetches the data to display this page, they make a request to the pre-existing <span class="code-snippet">/books</span> endpoint designed for the desktop application. Since the REST API has not yet been adapted for this new use case, the current endpoint returns information that doesn’t fit the mobile application's data needs. This is known as over-fetching. Figure 5 shows the <span class="code-snippet">/books</span> endpoint’s response which has all the book information, but the mobile application doesn’t need all of that data.
          </p>

          <figure>
            <img src="assets/media/diagrams/6.png" class="case-study-image" />
            <figcaption>Fig.5 - Over-fetching data can lead to system performance issues.</figcaption>
          </figure>

          <p>
            More data transferred in each request means longer wait times for the frontend to receive and process the data. Over-fetching can lead to a user experiencing higher response times, resulting in a slower page load. Sending too much data is especially problematic on mobile devices. Mobile networks have less bandwidth, which means slower data transfer. A typical page takes ~88% longer to load on mobile devices than on a desktop. This bookstore example is simplified; as applications scale, the user experience on a mobile device can degrade to the point where users may leave before the page loads.
          </p>

          <p>
            Another part of the mobile application needs to load a cart page that lists which books a user has in their cart. Books and carts are represented by separate endpoints in the API, so the frontend developers must make multiple requests to fetch all the necessary information to load the cart. Since one endpoint doesn’t contain all the required data, they are “under-fetching.” Under-fetching can cause a “waterfall” effect of requests cascading to many more related requests, resulting in multiple round trips between the client and server.
          </p>

          <figure>
            <img src="assets/media/diagrams/7.png" class="case-study-image" />
            <figcaption>Fig.6 - Under-fetching data can lead to additional requests to complete a page.</figcaption>
          </figure>

          <p>
            The time it takes for a request to be sent over the network from client to server and back is known as round-trip latency. While round-trip latency varies, it can take roughly 207ms on average. When under-fetching leads to additional unnecessary round-trips, the latency from the other requests can significantly increase page load time. Every five additional requests might lead to 1000ms of load time. Since many users will leave a page that is still loading after 10,000ms, even a handful of unnecessary requests can contribute to lost users.
          </p>

          <figure>
            <img src="assets/media/diagrams/8.png" class="case-study-image" />
            <figcaption>Fig.7 - Round-trip latency leads to longer page load times, especially for mobile clients</figcaption>
          </figure>

          <p>
            Beyond application performance, over-fetching and under-fetching affect frontend developer productivity. When an API does not match their frontend client’s data needs well, developers must spend additional time orchestrating many requests and filtering unnecessary data. In some cases, dealing with data can take the majority of frontend development time, leaving little time to spend on building critical UI.
          </p>

          <figure>
            <img src="assets/media/diagrams/9.png" class="case-study-image" />
          </figure>

          <h3 id="section-2-3">2.3 Adapting an API</h3>

          <p>
            Development teams faced with supporting multiple clients are not limited to using fixed endpoints that cause under-fetching and over-fetching. They can adapt their REST APIs to make them better fit each of their frontend use cases. Adding new endpoints, providing query parameters for customized requests, or versioning their API for each use case are a few options.
          </p>

          <figure>
            <img src="assets/media/diagrams/10.png" class="case-study-image" />
            <figcaption>Fig.8 - Adjusting & creating endpoints to accommodate new client use cases</figcaption>
          </figure>

          <p>
            Introducing customization makes a REST API more flexible. However, these adaptations make it more complex and challenging to work with for API providers. In a recent survey by Postman, 51% of respondents reported over half of their organization’s development effort is dedicated to APIs. As the complexity grows, adapting the API can become a critical bottleneck, slowing the addition of future client use cases.
          </p>

          <figure>
            <img src="assets/media/diagrams/11.png" class="case-study-image" />
          </figure>

          <p>
            Creating and managing documentation can also take time away from the backend developer’s primary responsibilities. As the API changes and adaptations are made, the documentation becomes more challenging to maintain, requiring more time to keep up-to-date. This may not always be possible, which is why API documentation is often considered a “nice-to-have” on the priority list for providers. However, documentation is critical for API consumers, and poor or missing information about endpoints compounds the challenges faced by the frontend team.
          </p>
         
          <p>
            While our hypothetical bookstore example is simplified for demonstration, in reality, the developers often need to interact with many APIs to fetch all the data they need. This means they deal with data access issues across multiple APIs and data sources, increasing the complexity and the time necessary to deal with it.
          </p>

          <p>
            REST is widespread because it works well for applications where the API can be optimized for a use case, and data access patterns match the provided endpoints. While endpoints can be adapted in various ways to facilitate request customization, this comes at the cost of complexity and developer time. However, several vital factors may influence a team to re-consider how they structure an API:
          </p>
          
          <ul>
            <li>Support is needed for frontend applications that have different bandwidth needs</li>
            <li>Data access is nested, interrelated, recursive, or varies frequently</li>
            <li>Data is distributed across multiple sources</li>
          </ul>

          <p>
            A new API paradigm, GraphQL, emerged in 2015 as an option to create APIs that are highly customizable and flexible for such use cases.
          </p>

          <!-- Section 3 -->
          <h2 id="section-3" class="h2">3. GraphQL</h2>

          <p>
            Unlike multi-endpoint APIs like REST, a GraphQL API exposes a single endpoint. This difference contributes to many of the benefits GraphQL can offer.
          </p>

          <figure>
            <img src="assets/media/diagrams/12.png" class="case-study-image" />
            <figcaption>Fig.9 - All client types query the same single endpoint</figcaption>
          </figure>

          <p>
            With GraphQL, each frontend client uses a single endpoint to request the required data. To support fetching multiple resources for differing client types using the same endpoint, GraphQL introduces a query language that clients use to request the data. Client-side developers no longer need to keep track of many different endpoints and their different standards. Furthermore, API developers no longer need to add new endpoints, adapt their endpoints, or version them for different client types. By moving to one endpoint, both providers and clients can save time.
          </p>

          <figure>
            <img src="assets/media/diagrams/13.png" class="case-study-image" />
            <figcaption>Fig.10 - A query specifies the data, and the response matches the query structure</figcaption>
          </figure>

          <p>
            Let’s return to the hypothetical bookstore example from above. Data was over-fetched because the information needed for the desktop application differed from the mobile application. How can GraphQL fix this? A GraphQL query specifies the data a client needs, and the response structure matches that query. Queries are customizable, and the same query can fetch multiple resources simultaneously. The response will contain precisely the information requested, no more, no less. This change helps the developers save time and reduces the amount of data sent over the wire.
          </p>

          <figure>
            <img src="assets/media/diagrams/14.png" class="case-study-image" />
            <figcaption>Fig.11 - Each client can specify the required data with custom queries</figcaption>
          </figure>

          <p>
            We also saw how under-fetching could lead to round-trip latency. How can GraphQL help with this? A single query can fetch all the necessary data for the client, preventing cascading waterfall requests. Developers no longer have to wait for multiple requests to make round trips to the API server. It’s important to note there may still be multiple round trips needed to fetch data from various data sources. However, these can happen from API server to data source rather than from client to server.
          </p>

          <figure>
            <img src="assets/media/diagrams/15.png" class="case-study-image" />
            <figcaption>Fig.12 - Latency is reduced for clients and pushed to the GraphQL layer</figcaption>
          </figure>

          <p>
            GraphQL APIs are self-documenting and can be quickly introspected to view available query options. As a result, API providers no longer have to create and maintain documentation, which can drastically help the provider save time and improve productivity.
          </p>          

          <h3 id="section-3-1">3.1 GraphQL Implementation Challenges</h3>
          
          <p>
            While the frontend developers enjoy the benefits of a single endpoint, the responsibility for supporting a GraphQL API falls to the backend team.
          </p>

          <p>
            Building a GraphQL API introduces new challenges and pitfalls for API developers. First, developers must get up to speed on the GraphQL specification and learn about the unique components that make up a GraphQL server. The learning curve can be steep because GraphQL differs significantly from REST. They’ll also need to decide on an approach to writing their schema and combining them. Each approach has its tradeoffs, which can complicate the decision and slow the setup process.
          </p>
        
          <p>
            Secondly, the developer must deploy their new server so that frontend clients can query the API. They will need to decide which cloud services to utilize among the many options, provision and connect their chosen services, and deploy and manage that infrastructure.
          </p>

          <figure>
            <img src="assets/media/diagrams/16.png" class="case-study-image" />
          </figure>

          <p>
            Many steps go into building and deploying an initial GraphQL server, and this process can be time-consuming, tedious, and error-prone. The process of migrating from REST or adding a GraphQL layer to an existing application can take weeks or longer.
          </p>

          <p>
            To understand the challenge that development teams face, let’s take a closer look at what it takes to build a GraphQL API connected to multiple data sources.
          </p>

          <h3 id="section-3-2">3.2 Server Components</h3>
          
          <p>
            The main components of a GraphQL server are the schema and resolvers. A GraphQL schema defines the data types that can be requested and the relationships between types. Resolvers are functions that retrieve the requested data specified in the schema.
          </p>

          <figure>
            <img src="assets/media/diagrams/17.png" class="case-study-image" />
            <figcaption>Fig.13 - Server responsibilities to support a single endpoint</figcaption>
          </figure>

          <p>
            A GraphQL schema comprises type definitions, which describe a queryable type within the GraphQL API. Each type includes fields that define the properties of that type, and each field can be a base type, like String or Integer. To support the graph data structure of GraphQL, fields are also used to represent associations between types. For example, a type of “Book” may have a field “author” which corresponds to an “Author” type, thus associating those two types.
          </p>

          <figure>
            <img src="assets/media/diagrams/18.png" class="case-study-image" />
          </figure>

          <p>
            The default type <span class="code-snippet">Query</span> represents one entry point into the schema and actions that retrieve data. The <span class="code-snippet">Query</span> type contains fields that the GraphQL schema creator defines. The GraphQL specification also includes default types of <span class="code-snippet">Mutation</span> for adding or modifying data and <span class="code-snippet">Subscription</span> to support streaming data with GraphQL.
          </p>

          <figure>
            <img src="assets/media/diagrams/19.png" class="case-study-image" />
          </figure>

          <p>
            Resolvers are functions that can take a GraphQL query and respond with the appropriate data for each field in the query. They are defined by the developer and specify how the data for fields in the type definitions are retrieved.
          </p>

          <h3 id="section-3-3">3.3 Schema Writing Approaches</h3>
          
          <p>
            Before developers can create a schema, they may choose between two approaches for schema writing: schema-first or code-first. The schema-first approach utilizes the GraphQL Schema Definition Language or SDL for short. Using SDL allows the developer to define their schema in a programming language-agnostic way.
          </p>

          <p>
            The SDL includes syntax for defining the types that form the GraphQL data model. A schema written using the SDL provides a holistic picture of the data and associations within an application.
          </p>

          <figure>
            <img src="assets/media/diagrams/20.png" class="case-study-image" />
          </figure>

          <p>
            Since the SDL is not tied to a specific programming language, the resulting schema outlines the data model without implementation details. In a schema-first approach, the schema and resolvers are written separately. Since resolvers define how data is retrieved, they must be written in the developer’s chosen programming language.
          </p>

          <p>
            For a code-first approach, the process begins with writing types with resolvers directly in the desired programming language. For example, using the “graphql” library in Node.js, the developer can use imported JavaScript objects to create their type definitions with fields and corresponding resolvers. In this approach, the code serves as the schema, and an SDL version can be generated from the code using scripts.
          </p>

          <figure>
            <img src="assets/media/diagrams/21.png" class="case-study-image" />
          </figure>

          <p>
            Each approach has tradeoffs. The schema-first approach divides the type definitions and resolvers, separating concerns. The singular focus makes it easier to understand and quickly share the data model. However, it involves a new language, and the SDL-defined schema is not complete on its own. Additionally, the separation of resolvers can lead to duplication requiring more maintenance over time.
          </p>

          <p>
            Unlike the schema-first approach, the code-first approach is self-contained, which means the entire schema is defined in one place. Consequently, the overall structure of the data model can be more challenging to understand in code form.
          </p>

          <p>
            As multiple data sources are added, the complexity of a schema grows. Many teams will opt to modularize their schema, separating each data source into its own schema. They will then need a strategy to combine them into a unified schema if they want to maintain the benefits of a single endpoint. There are several ways for the developer to implement this, but each has its own tradeoffs to consider.
          </p>

          <figure>
            <img src="assets/media/diagrams/22.png" class="case-study-image" />
          </figure>

          <p>
            GraphQL’s Schema Definition Language, type definitions, resolvers, and schema writing approaches are fundamental to building a GraphQL API from scratch. While there are libraries to ease the process, it can still take weeks for developers brand new to GraphQL.
          </p>
        
          <h3 id="section-3-4">3.4 Deployment</h3>

          <figure>
            <img src="assets/media/diagrams/23.png" class="case-study-image" />
          </figure>

          <p>
            We’ve discussed a few challenges developers face as they learn how to build a server in this new paradigm, but building the server is only half the battle. The developer still needs to deploy the server for the frontend team to make queries. This process can be complicated and involves many steps.
          </p>

          <p>
            When deploying their server to the cloud, there are a variety of platforms a developer might choose. We focus on the most popular Amazon Web Services, also known as AWS. 
          </p>

          <ul>
            <li>IAM User Roles</li>
            <li>VPC</li>
            <li>Public Subnet in VPC</li>
            <li>Security Group for Public Subnet</li>
            <li>EC2 Instance in Public Subnet</li>
            <li>Routing Table</li>
            <li>Router</li>
            <li>Internet Gateway
            </li>
          </ul>
          
          <p>
            Although this is a rudimentary infrastructure, it still has several resources to be provisioned. A developer must understand these resources and their related services when deploying an API from scratch. 
          </p>

          <figure>
            <img src="assets/media/diagrams/24.png" class="case-study-image" />
            <figcaption>Fig.14 - AWS Services</figcaption>
          </figure>

          <p>
            Currently, AWS offers 200+ services, with more added all the time. You can see an example of these services in figure 14. The sheer volume of services, plus their confusing names and acronyms, has inspired several “AWS in plain English” articles to be written that strive to explain what each service is used for and what it should have been called instead.
          </p>

          <p>
            Once the developer learns what resources are needed, they must also make them work together. However, coordinating communication between resources can introduce bugs that take more work to troubleshoot, can be tedious for the developer, and increase the time spent getting a server running for clients to query.
          </p>

          <p>
            Finding the right resources is only one hurdle the developer needs to overcome; they must also choose the right ones to support their architecture. This step can be complex and, if done improperly, can affect the performance of their application.
          </p>

          <p>
            AWS provides a few different tools to assist the developer in provisioning resources. First is a graphical interface used to provision resources by hand. Next is a command line interface that can be used to provision resources by interacting with the API.
          </p>

          <figure>
            <img src="assets/media/diagrams/25.png" class="case-study-image" />
            <figcaption>Fig.15 - AWS CLI commands to provision a single EC2 instance</figcaption>
          </figure>

          <p>
            Both of these tools strive to make provisioning convenient for the developer. However, they both involve dozens of sequential steps to provision and connect the different resources required. In figure 15, you can see an example of some commands that need to be run in the AWS CLI to provision a single EC2 instance. Although this is a simplified example, the documentation for EC2 alone offers 575 commands. This volume is what developers struggle with. Although having many options can be good, navigating them can also be challenging, especially for someone new to infrastructure.
          </p>

          <figure>
            <img src="assets/media/diagrams/26.png" class="case-study-image" />
          </figure>

          <p>
            In a small business or non-profit, the responsibility for managing the whole stack falls to a few developers or sometimes a single developer. The rise of mobile apps and the increasing prevalence of “smart” devices require building applications for various client types. The small team will be responsible for adding new frontend clients as needed and building the APIs to support those clients. In addition, as services are outsourced or otherwise distributed, they must deal with more internal and external data sources.
          </p>

          <p>
            Large organizations can often afford to dedicate teams of developers to learn the GraphQL specification and implement their API in-house. Smaller organizations may decide early in their initial research that the complexity that GraphQL brings outweighs the benefits. Besides the performance benefits, the secondary goal of switching to GraphQL is to save developer time. If the time spent getting the API running is more than the time saved on the frontend, switching to GraphQL will not appear to be worth it.
          </p>

          <p>
            Small teams can benefit from an alternative to building their own GraphQL API. As they explore the GraphQL ecosystem, they will find several existing solutions that can help make the process faster and easier.
          </p>

           <!-- Section 4 -->
          <h2 id="section-4" class="h2">4. Existing Solutions</h2>

          <p>
            Given the considerable amount of time it takes to learn and implement a GraphQL API, an alternative approach that some teams may consider is using a tool that generates their API. We looked at several options that led us to develop Nexus as an alternative to the existing solutions.
          </p>

          <h3 id="section-4-1">4.1 Managed Cloud Services</h3>

          <p>
            At the highest level of abstraction are managed cloud services like Hasura and StepZen. These are GraphQL API generators that automatically create, manage, and deploy the server for the user.
          </p>

          <p>
            With a managed service, setup can be done in just a few minutes, and previous knowledge of GraphQL isn’t required to get an API running. Most managed services support a wide variety of data sources and offer the ability to combine data sources into a unified GraphQL layer. 
          </p>

          <p>
            However, a managed service may only support some data sources, so developers must ensure the sources they currently use are supported. If they don’t, they will either have to switch to a service that supports their required data source or start over and build their server from scratch.
          </p>

          <figure>
            <img src="assets/media/diagrams/27.png" class="case-study-image" />
          </figure>

          <p>
            Deployment is also handled entirely by the service. Automated deployment is one of the primary benefits of using a managed service, but it has some tradeoffs. Outsourcing deployment results in a lack of control over the infrastructure that supports the API. There is also no opportunity to optimize the cost of that infrastructure.
          </p>

          <p>
            As an added benefit, managed services typically offer a robust set of additional API optimization features, like caching, monitoring, and observability. If the developer needs these other features, they can incorporate them in a few clicks, making them reasonably simple to implement.
          </p>

          <p>
            Managed services abstract much of the complexity away from the user, leading to speed and ease of setup. However, they trade off extendability and control. 
          </p>

          <h3 id="section-4-2">4.2 Open Source Libraries</h3>

          <p>
            Developers who want additional control and extendability can use several open-source GraphQL API generator libraries, like WunderGraph or GraphQL Mesh.
          </p>

          <p>
            Generator libraries help get developers started more quickly than writing GraphQL code from scratch. However, they still require manual setup and configuration, which often involves some basic GraphQL knowledge and library-specific syntax.
          </p>

          <figure>
            <img src="assets/media/diagrams/28.png" class="case-study-image" />
          </figure>

          <p>
            Generator libraries support a wide variety of data sources. Unlike managed services, they are also highly extendable because the developer can access the generated code. For data sources that aren’t supported, the developer can extend the schema manually or with plugins. 
          </p>
          
          <p>
            The ability to add data sources is only one of many ways the developer can extend their server. They can also utilize plugins to add more advanced features. If there isn’t a plugin for their needs, they can manually extend their code to fit their use case. Extensibility is one of the main benefits of using open-source libraries and why a developer may choose to use them.
          </p>

          <p>
            Although generator libraries help create the server, they do not deploy the server for the developer once it is generated. Some libraries have documentation that may include basic deployment guides for different cloud providers and architectures, but they do not typically provide direct assistance with deployment. Without deployment assistance, developers fully control their infrastructure decisions and cost. Ultimately, this comes at the expense of the developer’s time and the deployment complexity we described previously.
          </p>

          <h3 id="section-4-3">4.3 Nexus</h3>

          <p>
            Nexus is a framework for quickly generating a GraphQL API from multiple data sources and deploying the API to a user’s AWS account. We wrap several open-source tools for API generation and deployment, speeding up the configuration and use of those tools. We built Nexus for teams who would like to build and deploy a simple GraphQL API in just a few minutes, with the option to extend it over time.
          </p>

          <p>
            Nexus uses GraphQL Mesh, a powerful GraphQL API generator, to build the user’s server. We reduced the configuration of this open-source library to a few simple commands, so no experience with GraphQL or the Mesh library is needed to get started.
          </p>

          <figure>
            <img src="assets/media/diagrams/29.png" class="case-study-image" />
          </figure>

          <p>
            Nexus currently supports three data sources: Postgres, REST APIs, and GraphQL APIs. If a data source is not supported, the user can extend their API using Mesh’s collection of additional sources or manually extend the schema.
          </p>

          <p>
            After the server is generated, Nexus deploys the GraphQL server with a single command. We simplify deployment by abstracting away infrastructure setup and making a few decisions for the user. The deployed infrastructure is then provisioned entirely in their AWS account and is fully modifiable by the user.
          </p>

          <p>
            Although Nexus offers many beneficial features, we don’t provide advanced options for fine-tuning the API like managed services. As a result, users have some of the benefits of extendability and ownership that come with an open-source library, along with some of the deployment abstractions of a managed service, at the cost of advanced API features. However, users can add features as needed because the generated code lives on their local machine.
          </p>
        
          <!-- Section 5 -->
          <h2 id="section-5" class="h2">5. Nexus Walkthrough</h2>
          <h3 id="section-5-1">5.1 Download and Setup</h3>
         
          <figure>
            <img src="assets/media/diagrams/30.png" class="case-study-image" />
          </figure>

          <p>
            Nexus is available as an NPM package. Global installation gives users access to all the commands and a local admin dashboard. Prerequisites and installation instructions are listed in the <a href="https://github.com/nexus-graphql/nexus-cli"> readme section of our GitHub repository</a>.
          </p>

          <figure>
            <img src="assets/media/diagrams/31.gif" class="case-study-image" />
          </figure>

          <h3 id="section-5-2">5.2 Initializing GraphQL API Server</h3>
        
          <p>
            After installation, the user can initialize a new project with the <span class="code-snippet">init</span> command. They’ll run this in an empty project folder where we’ll generate their server files. We collect a Postgres database as the primary data source. To avoid confusing bugs when the server is generated, the Postgres connection string is validated for the user when they input it.
          </p>

          <figure>
            <img src="assets/media/diagrams/32.png" class="case-study-image" />
          </figure>

          <p>
            Behind the scenes, we install the necessary packages and create the configuration files to generate and run the GraphQL server in the user’s current working directory. They now have a basic GraphQL server built from their Postgres database with a single command.
          </p>

          <h3 id="section-5-3">5.3 Adding Other Data Sources</h3>
          
          <p>
            Adding a second data source is similar to adding the initial Postgres database. The <span class="code-snippet">nexus add</span> command will prompt the user for the data source type and then tailor subsequent prompts based on that source type. This command can add REST endpoints, a remote GraphQL API, or another Postgres database.
          </p>

          <figure>
            <img src="assets/media/diagrams/33.png" class="case-study-image" />
          </figure>

          <p>
            REST endpoints are included using a local path or remote URL to a JSON file that defines the user’s endpoints following the OpenAPI specification. Adding a GraphQL data source can be done by providing the URL of the API.
          </p>
          
          <h3 id="section-5-4">5.4 Testing the Server Locally</h3>

          <p>
            After the user initializes their server and adds one or more data sources, they can test their API locally by running the <span class="code-snippet">nexus dev</span> command. This opens a graphical interface for exploring the unified schema and making test queries. The test server supporting this interface is identical to the server that will be deployed, so it can be used to accurately pre-plan client queries.
          </p>

          <figure>
            <img src="assets/media/diagrams/34.png" class="case-study-image" />
          </figure>

          <h3 id="section-5-5">5.5 Deployment</h3>

          <p>
            Nexus simplifies the deployment process down to a single command: <span class="code-snippet">nexus deploy</span>. This command handles all the complexity of packaging the server code and provisioning the infrastructure. 
          </p>

          <figure>
            <img src="assets/media/diagrams/35.gif" class="case-study-image" />
          </figure>

          <p>
            After a few minutes, the server is deployed to the user’s AWS account. They’ll get back a URL in the command line that they can use to query the deployed GraphQL server from any of their frontend clients.
          </p>

          <h3 id="section-5-6">5.6 Dashboard</h3>

          <p>
            Once the server is deployed, the user can use the <span class="code-snippet">nexus dashboard</span> command to run a local dashboard that displays information about their API. This includes their deployed server's status, endpoint, authorization key, and current data sources. Additionally, they can add, edit, or delete data sources from their dashboard. An integrated local test server is included in the “GraphiQL” tab.
          </p>

          <figure>
            <img src="assets/media/diagrams/36.png" class="case-study-image" />
          </figure>

          <p>
            If the user makes changes to the data sources, a message will alert them to redeploy. Redeployment can be done in the dashboard with a single click or with the <span class="code-snippet">nexus redeploy</span> command.
          </p>

          <h3 id="section-5-7">5.7 Destroy</h3>
         
          <p>
            If the user wants to remove the provisioned infrastructure at any time, they can use the destroy command to deprovision all AWS services that have been set up.
          </p>

          <figure>
            <img src="assets/media/diagrams/37.gif" class="case-study-image" />
          </figure>

          <p>
            Since the infrastructure is deployed to their AWS account, they can make changes directly within the AWS console. However, the destroy command ensures all services are removed at once so the user is not charged for services that could be overlooked with manual de-provisioning.
          </p>

          <!-- Section 6 -->
          <h2 id="section-6" class="h2">6. Nexus Architecture</h2>

          <p>
            Next, we will go into the technical aspects of how Nexus was built and some of the decisions we made along the way. We can illustrate the Nexus workflow in two parts: generating the GraphQL API Server and deploying it.
          </p>

          <figure>
            <img src="assets/media/diagrams/38.png" class="case-study-image" />
          </figure>

          <h3 id="section-6-1">6.1 Generating the Server</h3>
        
          <p>
            One of the initial problems we had to solve was generating a schema from a database. There are several libraries built for this purpose, and we initially explored one of them: Postgraphile. Postgraphile allowed us to generate a GraphQL schema from a Postgres database, but it could not generate schemas from other data sources. This was a problem because we wanted the ability to support more than one data source.
          </p>

          <p>
            We explored using additional libraries alongside Postgraphile to accomplish our goal, but we ultimately found another library that could handle our desired use case: GraphQL Mesh. Nexus wraps Graphql Mesh to generate schemas and combine them into a unified GraphQL API. Ultimately, this allows users to have one endpoint that interacts with multiple data sources. 
          </p>

          <h4 id="section-6-1-1">6.1.1 Initializing a Server and Integrating Data Sources</h4>

          <p>
            The main point of interaction between Nexus and Mesh is through a configuration file, where YAML is used to specify various options.
          </p>

          <p>
            When a user interacts with the Nexus command line tool, they start by entering the <span class="code-snippet">init</span> command. Behind the scenes, this command first installs necessary GraphQL Mesh packages and creates a configuration file in the user’s current working directory. Nexus prompts the user for a Postgres connection string, which is then validated using the <span class="code-snippet">pg-promise</span> library to make a connection to the database. The validated database connection information is then passed to a template, which will format it into valid YAML. Lastly, the formatted YAML is supplied to the configuration file.
          </p>

          <p>
            The <span class="code-snippet">add</span> command adds additional data sources to the configuration file. The user provides data source information to Nexus, which is then formatted into YAML and supplied to the configuration file.
          </p>

          <figure>
            <img src="assets/media/diagrams/39.png" class="case-study-image" />
          </figure>

          <p>
            Once the data sources are added to the configuration file, GraphQL schemas can be created for every data source provided to it. Each data source is consumed by a source handler that introspects or gathers information about the data source. The result of introspecting each data source is an individual GraphQL schema defined using the SDL.
          </p>

          <p>
            Schema customization, in the form of transformations, can be implemented at both the individual and unified schema levels. For example, we add an authorization middleware function to the unified schema for the user to prevent unauthorized access.
          </p>

          <p>
            Once the schemas are generated, combined, and any modifications applied, the local GraphQL server is ready to deploy.
          </p>

          <h3 id="section-6-2">6.2 Deploying the Server</h3>
          
          <figure>
            <img src="assets/media/diagrams/40.png" class="case-study-image" />
          </figure>

          <p>
            When a user runs <span class="code-snippet">nexus deploy</span>, within a few minutes, their server is automatically deployed to an AWS infrastructure that is provisioned for them. Even though it is a simple process for the user, many things have to happen in the background for that to occur.
          </p>

          <figure>
            <img src="assets/media/diagrams/41.png" class="case-study-image" />
          </figure>

          <p>
            Since we generate the GraphQL server on the user’s local machine, we need a reliable way to deploy their application code and ensure that it runs on their AWS infrastructure. We chose to deploy using containerization. Let’s briefly discuss the process and clarify a few terms.
          </p>

          <p>
            Nexus writes the GraphQL server code on the developer's machine. This application code has dependencies that also live on their machine. Suppose the application is transferred to a new machine; errors may occur due to the application's dependencies not being present. Containerization encapsulates the application code, libraries, and dependencies required for the software to run. Doing this allows the application to be run on different systems while reducing dependency issues.
          </p>

          <p>
            Docker is an open-source implementation for containerization. A Docker image is like a blueprint of the application, which includes all the dependencies. We store Docker images in a repository, similar to storing source code on a remote repository like GitHub. Containers are created through images and run the actual application code. We can then pull the Docker image from a repository onto a cloud machine to run the application.
          </p>

          <figure>
            <img src="assets/media/diagrams/42.png" class="case-study-image" />
          </figure>

          <p>
            Creating and pushing a Docker image to a private repository, pulling the image down onto cloud infrastructure, and running a container from the image provided us with a code deployment workflow that helped eliminate application dependency issues between the user’s local machine and the cloud-hosted machine.
          </p>

          <figure>
            <img src="assets/media/diagrams/43.png" class="case-study-image" />
          </figure>

          <p>
            When the user runs the deploy command, we provision the AWS services to get their server up and running. We start by locally building a Docker image from their generated GraphQL server. Next, we use Terraform, an infrastructure as code tool, to create a private image repository on Amazon’s Elastic Container Registry. Terraform helps make deploying infrastructure more efficient by allowing users to provision AWS resources using code in Terraform configuration files. We considered using AWS’s service CloudFormation as an alternative to Terraform, but we wanted the ability to deploy on multiple cloud providers in the future.
          </p>

          <figure>
            <img src="assets/media/diagrams/44.png" class="case-study-image" />
          </figure>

          <p>
            The Docker image is pushed to the new repository using the AWS CLI. We also use Terraform to provision AWS Elastic Container Service and Fargate. Elastic Container Service makes managing and scaling containers easier. Fargate works alongside ECS to provision and manages all the infrastructure required to run the container, meaning the user will not have to manage the underlying EC2 instances directly. Together, they allow the developer to spend less time managing resources but still allow them to make changes or scale in the future.
          </p>

          <figure>
            <img src="assets/media/diagrams/45.png" class="case-study-image" />
          </figure>

          <p>
            One of the benefits of using ECS is that we can reference the ECR repository URL we created in the ECR Terraform configuration file during the provisioning of ECS and Fargate. This allows the server to run as soon as the instance is live with no additional configuration. That process is partially made possible by Terraform modularization. Modularization is a collection of Terraform configuration files grouped in a directory. By modularizing the configuration files, it is possible to reference details about the resources created, such as the ECR repository URL, in the ECS module. Consequently, the image pushed to the ECR is immediately running as soon as the instance is live. Figure 16 shows the high-level AWS infrastructure after deployment is complete.
          </p>

          <figure>
            <img src="assets/media/diagrams/46.png" class="case-study-image" />
            <figcaption>Fig.16 - High-Level AWS Infrastructure after Deployment</figcaption>
          </figure>

          <h3 id="section-7">7 Nexus Implementation Challenges</h3>

          <p>
            We’d now like to highlight a few of the technical challenges we encountered as we built Nexus.
          </p>

          <h3 id="section-7-1">7.1 Connecting Multiple Data Sources</h3>

          <p>
            After users have initialized their Nexus project, they have a GraphQL API that each client can query for the data they need. While each data source has been combined in the unified schema, there’s still a problem.
          </p>

          <p>
            Data stored across multiple sources is often related. An example could be product data, such as books stored in a database, with cart information stored in Shopify. When separate data sources containing related data are combined in a generated server, the relationship across sources isn’t automatically recognized. We can still fetch information from both in a single query. However, the relationship that exists between these two sources isn’t represented in our GraphQL API.
          </p>

          <figure>
            <img src="assets/media/diagrams/47.png" class="case-study-image" />
          </figure>

          <p>
            Since we can’t shape a query that shows a relationship between the two data sources, we retrieve a response that includes the data for one cart and all books. The frontend developer would then need to filter the books required for this particular cart.
          </p>

          <p>
            Our challenge was to find a way to help the user define these inherent relationships between data sources within their GraphQL server. If we can connect these data sources, they can be queried together. Fetching a specific cart would only yield the books for that cart, even when books come from another source.
          </p>

          <p>
            In order to associate two data sources, we needed to capture a few pieces of information. We gather this from the user with a form on the dashboard. This form is built dynamically and prefilled with the available options based on the user’s generated schemas.
          </p>

          <figure>
            <img src="assets/media/diagrams/48.png" class="case-study-image" />
          </figure>

          <p>
            We need to know which types from two data sources the user would like to associate. To display these, we needed to load all the individual schemas and filter only the relevant types in each one. This ensures the user only sees valid options for types that can connect on the form. Here, we’ll use a cart and books to demonstrate.
          </p>

          <figure>
            <img src="assets/media/diagrams/49.png" class="case-study-image" />
          </figure>

          <p>
            Once we know the two types, we can display the available fields for each type for the user to select. These fields should represent the data association - typically an ID field stored in both data sources. In our example, the cart’s <span class="code-snippet">book id</span> field is directly related to the <span class="code-snippet">id</span> of a book. The user knows this, but our GraphQL server doesn’t.
          </p>

          <p>
            Once we know how the data is associated based on the user’s selections, we can build the necessary connection within the GraphQL schema.
          </p>

          <figure>
            <img src="assets/media/diagrams/50.png" class="case-study-image" />
          </figure>

          <p>
            First, we add a new field to the user’s cart, a book. In the background, we extend the cart schema by adding a new field to the cart type with a custom type definition in the user’s configuration file. This defines the association within the GraphQL server and will allow the user to request books related to a particular cart.
          </p>

          <p>
            Next, we need to define how to resolve this new book field. We accomplish this by adding an additional resolver within the user’s configuration file.
          </p>

          <p>
            Now, when the user queries a cart and selects the book field, the right book data is returned.
          </p>
          
          <figure>
            <img src="assets/media/diagrams/51.png" class="case-study-image" />
          </figure>

          <h3 id="section-7-2">7.2 Hot Reloading</h3>

          <p>
            When the user changes the server on the dashboard, as we saw with connecting two data sources, locally testing these changes is a logical next step. To assist with testing, we run a local development server accessible within the dashboard.
          </p>

          <figure>
            <img src="assets/media/diagrams/52.png" class="case-study-image" />
          </figure>

          <p>
            However, GraphQL Mesh offered no option for hot reloading this development server. We needed a way to keep the server up-to-date without forcing the user to shut down their dashboard every time they make a change, so we implemented our own hot reloading function.
          </p>

          <p>
            Anytime the user changes to their server, such as adding, editing, or deleting a data source, that change is reflected in their configuration file.
          </p>

          <figure>
            <img src="assets/media/diagrams/53.png" class="case-study-image" />
          </figure>

          <p>
            We used the watch function from Node’s file system library to keep track of changes within the configuration file. By adding an event listener to a <span class="code-snippet">watch</span> object, we could watch for changes within the GraphQL Mesh configuration file. When there is a change, the event listener executes a function that kills the running GraphiQL development server and loads a new one.
          </p>

          <p>
            By implementing this hot reloading function, we avoid outdated information in the user’s test server and prevent them from shutting down the entire Dashboard any time they change their server.
          </p>

          <h3 id="section-7-3">7.3 Time To Redeploy</h3>

          <p>
            In addition to reloading the dashboard’s local development server on user changes, we needed a clear redeployment workflow. As users shift their focus from configuring to testing, they may forget to redeploy the changes they’ve made. To help remind them that their local server is out of sync with their deployed server, we implemented a basic change notification system.
          </p>

          <figure>
            <img src="assets/media/diagrams/54.png" class="case-study-image" />
          </figure>

          <p>
            We created a helper function within the dashboard’s backend that is invoked on every user change. This function updates an environment variable in the project folder that tracks changes.
          </p>

          <p>
            We included logic in our React code for the dashboard that displays the alert if changes have been made and there is an active deployment. Redeployment is unnecessary if no server is deployed or changes have been made; in this case, the alert is not visible.
          </p>

          <p>
            When there are changes and a deployed server, the user can click the corresponding button to initiate redeployment. After they initiate redeployment, we lock the dashboard’s deploy and redeploy functionality until it is successful. 
          </p>

          <figure>
            <img src="assets/media/diagrams/55.png" class="case-study-image" />
          </figure>

          <p>
            In the background, the docker image is rebuilt locally. Once the image is ready, we use the AWS command line to push the new image to the user’s private image repository and then update Fargate to utilize the newest version of the image. Finally, we wait for a successful deployment and update the user’s dashboard to reflect the status. 
          </p>

          <!-- Section 8 -->
          <h2 id="section-8" class="h2">8. Future Work</h2>
          <h3 id="section-8-1">8.1 Customization of the GraphQL Schema</h3>

          <p>
            Allowing the user to customize their GraphQL schema would improve the quality of their server. For example, the user may have fields in a database table that they do not want to be visible in the schema. We would like to implement additional customization, such as allowing the users to toggle which fields of a database table they would like visible in their schema.
          </p>

          <h3 id="section-8-2">8.2 Multi-Cloud Deployment</h3>
          
          <p>
            Currently, Nexus only enables users to deploy on AWS. We would like to expand to include deployment to other cloud providers such as Google Cloud Platform, Digital Ocean, or Microsoft Azure.
          </p>

          <h3 id="section-8-3">8.3 Allowing Additional Data Sources</h3>
          
          <p>
            The team would like to allow more data sources that can be used when generating a server. Some data source types that we would like to include are MongoDB, SOAP APIs, gRPC APIs, and other flavors of SQL beyond Postgres.
          </p>

          <h3>Sources</h3>
          <ul>
            <li><a href="https://www.postman.com/state-of-api/">https://www.postman.com/state-of-api/</a></li>
            <li><a href="https://stepzen.com/blog/rest-versus-graphql">https://stepzen.com/blog/rest-versus-graphql</a></li>
            <li><a href="https://backlinko.com/page-speed-stats">https://backlinko.com/page-speed-stats</a></li>
            <li><a href="https://www.youtube.com/watch?v=eD7kLFGOgVw">https://www.youtube.com/watch?v=eD7kLFGOgVw</a></li>
            <li><a href="https://www.oreilly.com/library/view/linux-shell-scripting/9781785881985/bc450563-0a16-40a">https://www.oreilly.com/library/view/linux-shell-scripting/9781785881985/bc450563-0a16-40a</a></li>
            <li><a href="https://web.dev/rail/">https://web.dev/rail/</a></li>
            <li><a href="https://apiacademy.co/2022/05/key-use-cases-for-graphql-apis/">https://apiacademy.co/2022/05/key-use-cases-for-graphql-apis/</a></li>
            <li><a href="https://blog.logrocket.com/code-first-vs-schema-first-development-graphql/">https://blog.logrocket.com/code-first-vs-schema-first-development-graphql/</a></li>
          </ul>
        </div>
      </div>
    </div>

    <div id="presentation" class="main-section">
      <div class="bg-gray">
        <h2>Presentation</h2>
        
        <iframe
          src=""
          title="YouTube video player"
          frameborder="0"
          allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
          allowfullscreen
        ></iframe>
      </div>
    </div>

    <div id="our-team" class="main-section">
      <div>
        <div>
          <div>
            <h2>Meet our team!</h2>
            <p class="text-xl text-gray-300">
              We are currently looking for opportunities. If you liked what you
              saw and want to talk more, please reach out!
            </p>
          </div>
          <ul class="people">
            <li class="profile">
              <img
                class="mx-auto h-40 w-40 rounded-full xl:w-56 xl:h-56 lazy"
                data-src="assets/team/felicia2.png"
                alt=""
              />
              <div>
                <div>
                  <h3>Felicia Bacon</h3>
                  <p>College Station, TX</p>
                </div>

                <ul class="social">
                  <li>
                    <a href="mailto:feliciaiveliz@gmail.com" target="_blank"
                      ><i class="fas fa-envelope"></i
                    ></a>
                  </li>
                  <li>
                    <a
                      href="https://www.linkedin.com/in/felicia-iveliz-bacon"
                      target="_blank"
                      ><i class="fab fa-linkedin"></i
                    ></a>
                  </li>
                  <li>
                    <a href="https://github.com/feliciaiveliz" target="_blank"
                      ><i class="fab fa-github"></i
                    ></a>
                  </li>
                  <li>
                    <a href="https://feliciaiveliz.github.io" target="_blank"
                      ><i class="fas fa-globe"></i
                    ></a>
                  </li>
                </ul>
              </div>
            </li>

            <li class="profile">
              <img
                class="mx-auto h-40 w-40 rounded-full xl:w-56 xl:h-56 lazy"
                data-src="assets/team/kim.png"
                alt=""
              />
              <div>
                <div>
                  <h3>Kimberly Ramirez</h3>
                  <p>Fort Collins, CO</p>
                </div>

                <ul class="social">
                  <li>
                    <a href="mailto:leena.lallmon@gmail.com" target="_blank"
                      ><i class="fas fa-envelope"></i
                    ></a>
                  </li>
                  <li>
                    <a
                      href="https://www.linkedin.com/in/leenalallmon/"
                      target="_blank"
                      ><i class="fab fa-linkedin"></i
                    ></a>
                  </li>
                  <li>
                    <a href="https://github.com/leena" target="_blank"
                      ><i class="fab fa-github"></i
                    ></a>
                  </li>
                  <li>
                    <a href="https://leenalallmon.com" target="_blank"
                      ><i class="fas fa-globe"></i
                    ></a>
                  </li>
                </ul>
              </div>
            </li>

            <li class="profile">
              <img
                class="mx-auto h-40 w-40 rounded-full xl:w-56 xl:h-56 lazy"
                data-src="assets/team/ben.png"
                alt=""
              />
              <div>
                <div>
                  <h3>Benjamin Perrault</h3>
                  <p>Tulsa, OK</p>
                </div>

                <ul class="social">
                  <li>
                    <a href="mailto:hello@sophiec.dev" target="_blank"
                      ><i class="fas fa-envelope"></i
                    ></a>
                  </li>
                  <li>
                    <a
                      href="https://www.linkedin.com/in/sophiecwy"
                      target="_blank"
                      ><i class="fab fa-linkedin"></i
                    ></a>
                  </li>
                  <li>
                    <a href="https://github.com/J-SophieCodes" target="_blank"
                      ><i class="fab fa-github"></i
                    ></a>
                  </li>
                  <li>
                    <a href="https://sophiec.dev" target="_blank"
                      ><i class="fas fa-globe"></i
                    ></a>
                  </li>
                </ul>
              </div>
            </li>

            <li class="profile">
              <img
                class="mx-auto h-40 w-40 rounded-full xl:w-56 xl:h-56 lazy"
                data-src="assets/team/matt.jpg"
                alt=""
              />
              <div>
                <div>
                  <h3>Matthew Malane</h3>
                  <p>Huntington Beach, CA</p>
                </div>

                <ul class="social">
                  <li>
                    <a href="https://vahid.blog/#contact" target="_blank"
                      ><i class="fas fa-envelope"></i></a>
                  </li>
                  <li>
                    <a
                      href="https://www.linkedin.com/in/vahiddejwakh"
                      target="_blank"
                      ><i class="fab fa-linkedin"></i
                    ></a>
                  </li>
                  <li>
                    <a href="https://github.com/dejwakh" target="_blank"
                      ><i class="fab fa-github"></i
                    ></a>
                  </li>
                  <li>
                    <a href="https://vahid.blog" target="_blank"
                      ><i class="fas fa-globe"></i
                    ></a>
                  </li>
                </ul>
              </div>
            </li>
          </ul>
        </div>
      </div>
    </div>

    <script src="javascripts/script.js"></script>
  </body>
</html>
