<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />

    <!-- BEGIN Info -->
    <meta
      name="description"
      content="Nexus- Fjord is an open-source framework that allows end users to receive Kafka streaming data in real-time."
    />
    <meta name="title" property="og:title" content="Fjord" />
    <meta property="og:type" content="Website" />
    <meta name="image" property="og:image" content="assets/thumb.png" />
    <meta
      name="description"
      property="og:description"
      content="Fjord - Fjord is an open-source framework that allows end users to receive Kafka streaming data in real-time."
    />
    <meta name="author" content="Fjord" />
    <!-- END Info -->

    <!-- BEGIN favicon -->
    <link
      rel="apple-touch-icon"
      sizes="180x180"
      href="assets/favicon/apple-touch-icon.png"
    />
    <link
      rel="mask-icon"
      href="assets/favicon/safari-pinned-tab.svg"
      color="#5bbad5"
    />
    <link rel="shortcut icon" href="assets/favicon/favicon.ico" />
    <meta name="msapplication-TileColor" content="#ffffff" />
    <meta
      name="msapplication-config"
      content="images/favicon/browserconfig.xml"
    />
    <meta name="theme-color" content="#ffffff" />
    <!-- END favicon -->

    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Nexus</title>

    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css"
    />
    <link
      rel="stylesheet"
      href="https://unpkg.com/@tailwindcss/typography@0.2.x/dist/typography.min.css"
    />
    <link rel="stylesheet" href="stylesheets/reset.css" />
    <link rel="stylesheet" href="stylesheets/style.css" />
    <link rel="stylesheet" href="stylesheets/responsive.css" />
  </head>
  <body>
    <header class="mobile-menu-closed">
      <div id="header">
        <a href="./index.html">
          <img src="assets/logo/main-logo.png" />
        </a>
        <nav>
          <a href="#start-here" class="selected">Overview</a>
          <a href="#case-study">Case Study</a>
          <a href="#presentation">Presentation</a>
          <a href="#our-team">Our Team</a>
          <a
            href="https://github.com/fjord-framework"
            target="_blank"
            class="icon"
            ><i class="fab fa-github"></i
          ></a>
        </nav>
        <div id="menu">
          <button type="button">
            <svg
              id="mobile-open"
              xmlns="http://www.w3.org/2000/svg"
              fill="none"
              viewBox="0 0 24 24"
              stroke="currentColor"
              aria-hidden="true"
            >
              <path
                stroke-linecap="round"
                stroke-linejoin="round"
                stroke-width="2"
                d="M4 6h16M4 12h16M4 18h16"
              />
            </svg>
            <svg
              id="mobile-close"
              xmlns="http://www.w3.org/2000/svg"
              fill="none"
              viewBox="0 0 24 24"
              stroke="currentColor"
              aria-hidden="true"
            >
              <path
                stroke-linecap="round"
                stroke-linejoin="round"
                stroke-width="2"
                d="M6 18L18 6M6 6l12 12"
              />
            </svg>
          </button>
        </div>
      </div>

      <div id="header-buffer"></div>

      <div id="mobile-menu">
        <a href="#start-here" class="selected">Overview</a>
        <a href="#case-study">Case Study</a>
        <a href="#presentation">Presentation</a>
        <a href="#our-team">Our Team</a>
        <a href="https://github.com/fjord-framework" target="_blank"
          ><i class="fab fa-github"></i></a>
      </div>
    </header>


    <div id="start-here" class="main-section">
      <div class="h-full">
        <div class="static-logo-color"></div>
        <div class="">
          <img
            class="nexus sm-screen"
            src="assets/logo/nexus-logo.png"
          />
          <img class="nexus lg-screen" src="assets/logo/nexus-name.png" />

          <p class="light-text">
            An open-source framework that<br />generates an instant
            <span class="text-pink">GraphQL server</span><br /> from
            <span class="text-teal">multiple data sources</span><br />
          </p>
        </div>
      </div>

      <div class="h-full">
        <div class="bg-dark-blue static-logo-blue">
          <h2>Instant GraphQL Server from Nexus</h2>
        </div>
        <div class="bg-dark-blue">
          <h2 class="sm-header">Real-time Streaming from Kafka</h2>
          <p>Fjord exposes real-time API endpoints to allow internet-facing clients to stream from Kafka </p>
          <video autoplay loop muted playsinline>
            <source src="./assets/media/mp4/API-Proxy-dark.mp4" type="video/mp4" />
            Your browser does not support the HTML5 Video element.
          </video>
        </div>
      </div>

      <div class="h-full">
        <div class="bg-light-blue static-logo-light-blue">
          <h2>Easy To Deploy</h2>
        </div>
        <div class="bg-light-blue">
          <h2 class="sm-header">Easy to Deploy</h2>
          <p>
            Use Fjord's CLI to deploy all the necessary infrastructure 
            to Amazon Web Services (AWS).
          </p>
          <img src="assets/media/gifs/fjordCLI.gif" class="cli"/>
        </div>
      </div>
      
      <div class="h-full">
        <div class="bg-dark-blue static-logo-blue">
          <h2>Scalable Infrastructure</h2>
        </div>
        <div class="bg-dark-blue">
          <h2 class="sm-header">Scalable Infrastructure</h2>
          <p>
            Fjord's infrastructure automatically scales up and down based on demand.
          </p>
          <img class="lazy" data-src="./assets/media/gifs/full_flow.gif"/>
        </div>
      </div>
      
    </div>

    <aside id="toc">
      <!-- Case Study <br /><br /> -->
      <ul>
        <!-- Section 1 -->
        <li data-section="section-1" class="selected">
          <a href="#section-1">
            <div>
              <div class="bullet"><div></div></div>
              <p>1. What is Fjord?</p>
            </div>
          </a>
        </li>
        <!-- Section 2 -->
        <li data-section="section-2">
          <a href="#section-2">
            <div>
              <div class="bullet"><div></div></div>
              <p>2. Use Case</p>
            </div>
          </a>
        </li>
        <li data-section="section-2" class="subitem">
          <a href="#section-2-1">
            <div>
              <div class="bullet"><div></div></div>
              <p>Who Might Use Ford?</p>
            </div>
          </a>
        </li>
        <li data-section="section-2" class="subitem">
          <a href="#section-2-2">
            <div>
              <div class="bullet"><div></div></div>
              <p>SuperEats Example</p>
            </div>
          </a>
        </li>
        <!-- Section 3 -->
        <li data-section="section-3">
          <a href="#section-3">
            <div>
              <div class="bullet"><div></div></div>
              <p>3. What is Real-time?</p>
            </div>
          </a>
        </li>
        <li data-section="section-3" class="subitem">
          <a href="#section-3-1">
            <div>
              <div class="bullet"><div></div></div>
              <p>Defining Real-time</p>
            </div>
          </a>
        </li>
        <li data-section="section-3" class="subitem">
          <a href="#section-3-2">
            <div>
              <div class="bullet"><div></div></div>
              <p>Real-time Techniques</p>
            </div>
          </a>
        </li>
        <li data-section="section-3" class="subitem">
          <a href="#section-3-3">
            <div>
              <div class="bullet"><div></div></div>
              <p>Choosing a Real-time API</p>
            </div>
          </a>
        </li>
        <!-- Section 4 -->
        <li data-section="section-4">
          <a href="#section-4">
            <div>
              <div class="bullet"><div></div></div>
              <p>4. What is Kafka?</p>
            </div>
          </a>
        </li>
        <li data-section="section-4" class="subitem">
          <a href="#section-4-1">
            <div>
              <div class="bullet"><div></div></div>
              <p>The evolution that led to Kafka</p>
            </div>
          </a>
        </li>
        <li data-section="section-4" class="subitem">
          <a href="#section-4-2">
            <div>
              <div class="bullet"><div></div></div>
              <p>The rise of Apache Kafka</p>
            </div>
          </a>
        </li>
        <li data-section="section-4" class="subitem">
          <a href="#section-4-3">
            <div>
              <div class="bullet"><div></div></div>
              <p>Kafka, Real-time, and SuperEats</p>
            </div>
          </a>
        </li>
        <!-- Section 5 -->
        <li data-section="section-5">
          <a href="#section-5">
            <div>
              <div class="bullet"><div></div></div>
              <p>5. Why an API Proxy for Kafka?</p>
            </div>
          </a>
        </li>
        <li data-section="section-5" class="subitem">
          <a href="#section-5-1">
            <div>
              <div class="bullet"><div></div></div>
              <p>Protocol Interoperability Issue</p>
            </div>
          </a>
        </li>
        <li data-section="section-5" class="subitem">
          <a href="#section-5-2">
            <div>
              <div class="bullet"><div></div></div>
              <p>Using an API Proxy as Middleware</p>
            </div>
          </a>
        </li>
        <li data-section="section-5" class="subitem">
          <a href="#section-5-3">
            <div>
              <div class="bullet"><div></div></div>
              <p>Additional Benefits of an API Proxy</p>
            </div>
          </a>
        </li>
        <!-- Section 6 -->
        <li data-section="section-6">
          <a href="#section-6">
            <div>
              <div class="bullet"><div></div></div>
              <p>6. Existing Solutions</p>
            </div>
          </a>
        </li>
        <li data-section="section-6" class="subitem">
          <a href="#section-6-1">
            <div>
              <div class="bullet"><div></div></div>
              <p>Paid Solutions</p>
            </div>
          </a>
        </li>
        <li data-section="section-6" class="subitem">
          <a href="#section-6-2">
            <div>
              <div class="bullet"><div></div></div>
              <p>DIY Approach</p>
            </div>
          </a>
        </li>
        <li data-section="section-6" class="subitem">
          <a href="#section-6-3">
            <div>
              <div class="bullet"><div></div></div>
              <p>Fjord: the only open source, full service solution</p>
            </div>
          </a>
        </li>
        <!-- Section 7 -->
        <li data-section="section-7">
          <a href="#section-7">
            <div>
              <div class="bullet"><div></div></div>
              <p>7. Building Fjord</p>
            </div>
          </a>
        </li>
        <li data-section="section-7" class="subitem">
          <a href="#section-7-1">
            <div>
              <div class="bullet"><div></div></div>
              <p>Overview of Triangular Pattern</p>
            </div>
          </a>
        </li>
        <li data-section="section-7" class="subitem">
          <a href="#section-7-2">
            <div>
              <div class="bullet"><div></div></div>
              <p>Design Goals</p>
            </div>
          </a>
        </li>
        <li data-section="section-7" class="subitem">
          <a href="#section-7-3">
            <div>
              <div class="bullet"><div></div></div>
              <p>The Evolution of Fjord</p>
            </div>
          </a>
        </li>
        <li data-section="section-7" class="subitem">
          <a href="#section-7-4">
            <div>
              <div class="bullet"><div></div></div>
              <p>Fjord's Architecture</p>
            </div>
          </a>
        </li>
        <!-- Section 8 -->
        <li data-section="section-8">
          <a href="#section-8">
            <div>
              <div class="bullet"><div></div></div>
              <p>8. Deploying & Using Fjord</p>
            </div>
          </a>
        </li>
        <li data-section="section-8" class="subitem">
          <a href="#section-8-1">
            <div>
              <div class="bullet"><div></div></div>
              <p>The Fjord CLI</p>
            </div>
          </a>
        </li>
        <li data-section="section-8" class="subitem">
          <a href="#section-8-2">
            <div>
              <div class="bullet"><div></div></div>
              <p>Customizing your infrastructure components</p>
            </div>
          </a>
        </li>
        <li data-section="section-8" class="subitem">
          <a href="#section-8-3">
            <div>
              <div class="bullet"><div></div></div>
              <p>Deploying Fjord to AWS</p>
            </div>
          </a>
        </li>
        <li data-section="section-8" class="subitem">
          <a href="#section-8-4">
            <div>
              <div class="bullet"><div></div></div>
              <p>Client-side Integration</p>
            </div>
          </a>
        </li>
        <!-- Section 9 -->
        <li data-section="section-9">
          <a href="#section-9">
            <div>
              <div class="bullet"><div></div></div>
              <p>9. Technical Challenges</p>
            </div>
          </a>
        </li>
        <li data-section="section-9" class="subitem">
          <a href="#section-9-1">
            <div>
              <div class="bullet"><div></div></div>
              <p>Auto-scaling and Load Balancing</p>
            </div>
          </a>
        </li>
        <li data-section="section-9" class="subitem">
          <a href="#section-9-2">
            <div>
              <div class="bullet"><div></div></div>
              <p>CORS Issue & Heartbeat</p>
            </div>
          </a>
        </li>
        <li data-section="section-9" class="subitem">
          <a href="#section-9-3">
            <div>
              <div class="bullet"><div></div></div>
              <p>Load Testing Fjord</p>
            </div>
          </a>
        </li> 
        <!-- Section 10 -->
        <li data-section="section-10">
          <a href="#section-10">
            <div>
              <div class="bullet"><div></div></div>
              <p>10. Future Work</p>
            </div>
          </a>
        </li>
        <li data-section="section-10" class="subitem">
          <a href="#section-10-1">
            <div>
              <div class="bullet"><div></div></div>
              <p>More Advanced Security Features</p>
            </div>
          </a>
        </li>
        <li data-section="section-10" class="subitem">
          <a href="#section-10-2">
            <div>
              <div class="bullet"><div></div></div>
              <p>Bidirectional Communication</p>
            </div>
          </a>
        </li>
      </ul>
    </aside>

    <div id="case-study" class="main-section">
      <div id="case-study-content">
        <div class="prose">         
          <h1>Case Study</h1>

          <!-- Section 1 -->
          <h2 id="section-1">1. What is Fjord?</h2>

          <p>
            Fjord is an open-source framework that enables client-side streaming from Kafka in real-time.
          </p>

          <figure>
            <img src="assets/media/images/vennDiagram.png" class="case-study-image" />
          </figure>

          <p>
            Through Fjord’s CLI, developers can easily and quickly deploy dozens of components on Amazon Web Services (AWS) to offload the streaming responsibilities to Fjord’s scalable real-time API proxy infrastructure. 
          </p>
          <video autoplay loop muted playsinline>
            <source src="./assets/media/mp4/API-Proxy-white.mp4" type="video/mp4" />
            Your browser does not support the HTML5 Video element.
          </video>
          <p>
            This enables any number of authorized end users--whether on a browser or a mobile app--to receive data streams from any number of Kafka topics from any number of Kafka clusters.          
          </p>
          <p>
            In this case study, we outline the key challenges we faced as we worked with real-time APIs, event driven architectures, and Kafka as an event streaming platform. 
          </p>
          <!-- Section 2 -->
          <h2 id="section-2" class="h2">2. Use Case & SuperEats example</h2>
          <h3 id="section-2-1">2.1 Who Might Use Fjord?</h3>
          <p>
            Any company or organization that uses Kafka may need to expose one or more Kafka topics to a client interface, whether because this is a central or tangential aspect of their business, or even just as an additional layer of human observability into a particular data stream.
          </p>
          <p>
            Building, hosting, and managing the infrastructure necessary to handle client-side 
            streaming from Kafka can be challenging, time consuming, and the kind of undifferentiated heavy lifting that is best outsourced to a third party.
          </p>
          <p>We see our target user as an organization that:</p>
          <ol>
            <li>Is <strong>large enough</strong> to already use Kafka for some aspect of their infrastructure,</li>
            <li>Wants to <strong>expose some stream of data</strong> (i.e. from a Kafka topic) in real-time to their employees, customers, suppliers, or any other type of stakeholder, including the public at large--or any combination of these.</li>
          </ol>
          <p>
            Of course, this organization is cost-conscious and wants the most efficient and easy way to deploy the infrastructure needed to solve this problem, while still managing, owning, and closely handling all the data themselves.
          </p>
          <h3 id="section-2-2">2.2 SuperEats Example</h3>
          <p>
            Let’s imagine that you run a company called SuperEats. Your company provides a platform that enables customers to order a meal from any registered restaurant, and independent contractors to pick up the order from that restaurant, and drive the meal to the customer.
          </p>
          <figure>
            <img src="assets/media/images/superEatsLogo.png" class="case-study-image" />
          </figure>
          <p>
            SuperEats works with thousands of restaurants, from well-known multinational chains like Chipotle to small hole-in-the-wall shops like Cousin Vinny’s Hot Dogs. Customers place an order from their favorite restaurant, which then comes into SuperEats’ Kafka cluster.
          </p>
          <figure>
            <img src="assets/media/gifs/supereats.gif" class="case-study-image" />
          </figure>
          <p>
            You want your platform to then not only send orders out to drivers, but also for customers to receive real-time updates at every step of the way. For example, customers should know when their meal was made, when the driver has picked it up, when the driver is about five minutes away from their home, and finally when their meal is at their doorstep.
          </p> 
          <p>
            To accomplish this, SuperEats needs a real-time infrastructure that is secure, easy to deploy and use, and takes advantage of their existing infrastructure.
          </p>

          <figure>
            <img src="assets/media/gifs/supereats_responds.gif" class="case-study-image" />
          </figure>
         
          <!-- Section 3 -->
          <h2 id="section-3" class="h2">3. What is Real-time?</h2>
          <h3 id="section-3-1">3.1 Defining Real-time</h3>
          
          <p>
            Ably, a leader in the real-time space, defines real-time thus:
          </p>
          <figure>
            <blockquote>
              <p>Real-time is the ability to react to anything that occurs as it occurs, before it loses its importance.</p>
            </blockquote>
          </figure>
          <p>
            This definition illustrates the main idea here: within the context of web applications, the goal of real-time streaming is to allow the recipient to get the information they need within sufficient time to adequately respond to it.
          </p>
          <figure>
            <img src="assets/media/gifs/Events.gif" class="case-study-image" />
          </figure>
          <p>
            Restaurants expect real-time updates on orders as soon as they are placed by customers. Customers expect updates on their order status, and drivers are constantly on the look out for nearby delivery requests. 
            If any of these groups aren’t able to get updates in real-time, their user experience is degraded, and updates would no longer be meaningful.
          </p>
        
          <h3 id="section-3-2">3.2 Real-time Techniques</h3>
          <p>
            There are different techniques developers could use to deliver real-time updates over the web.
          </p>

          <h4>3.2.1  Long polling</h4>
          <p>
            With long polling, the client sends an initial HTTP request to the server, and the server then waits until there’s a new piece of data to send back. Once the server gets a new update, it sends a response and immediately closes the request. The client must then send yet a <strong>new</strong> request to receive another update from the server.
          </p>
          <figure>
            <img src="assets/media/gifs/polling.gif" class="case-study-image" />
          </figure>
          <p>
            This is great in situations when the rate of new message production is not high. For example, the current outdoor temperature usually doesn't significantly change every quarter or even hour.
          </p>
          <p>
            There are downsides to using long polling. Having the client send a new request and the server send a new response for every single new message not only adds more latency to the process, but also puts more work on both the client and the server.
          </p>
          
          <h4>3.2.2 Server Sent Events (SSE)</h4>
          <p>
            SSE (also known as EventSource) is a web API that enables a client to receive a continuous stream of data from a server.
          </p>
          <p>
            The client sends an HTTP request through the EventSource WebAPI, which lets the server know this request is for a stream of data. The server then returns a never-ending HTTP response whose headers indicate that the connection will be ongoing until explicitly closed. At the same time, the server starts to send any data received, all in <strong>the same HTTP response</strong>.
          </p>
          <figure>
            <img src="assets/media/gifs/sse.gif" class="case-study-image" />
          </figure>
          <p>
            Just like long polling, SSE is <strong>unidirectional</strong>. The data is only streaming from the server to the client, and not vice versa.
          </p>
          <p>
            However, the SSE approach is much more efficient than long polling, as there’s no longer the need to continuously open and close HTTP responses for every message. All data is being transmitted through one never ending HTTP response.
          </p>
          <p>
            SSE is therefore ideal for situations where the client is not regularly sending information to the server, but is instead receiving a constant stream from the server.
          </p>
          <h4>3.2.3 WebSockets</h4>
          <p>
            WebSockets is a protocol that allows a client and a server to repeatedly exchange data through a single TCP connection. This <strong>bidirectional</strong> protocol means that both the client and the server can send data to each other as long as the WebSocket connection remains open.
          </p>
          <figure>
            <img src="assets/media/gifs/ws.gif" class="case-study-image" />
          </figure>
          <p>
            The client first sends a normal HTTP request, but this request contains headers that ask the connection to be upgraded to a WebSocket connection. The server then sends a response that opens the bidirectional communication line over the WebSockets protocol.
          </p>
          <p>
            WebSockets are great in situations where both the server and the client need to frequently send data to each other, such as in online gaming and chat room applications. WebSockets are also seen as the de facto technology for real-time communication, which means that there’s a large community available for support, and many open source libraries available.
          </p>
          <h3 id="section-3-3">3.3 Choosing a Real-time API</h3>
          <figure>
            <img src="assets/media/gifs/triangular_pattern.gif" class="case-study-image" />
          </figure>
          <h4>3.3.1 Unidirectional v.s. Bidirectional</h4>
          <p>
            SSE’s unidirectional limitation was not an impediment in our use case. Our goal was always to stream content from Kafka to end users, and not vice versa. For a company like SuperEats, having all customers and drivers be able to send a stream of data back to the company’s Kafka cluster may actually open up a new set of challenges that would require additional security and maintenance. That was an additional challenge not warranted by our use case.
          </p>
          <p>
            It’s true that we could have still used WebSockets and just chosen to not implement any client-side push back to Kafka. But that would defeat the main purpose of using WebSockets in the first place.
          </p>
          <p>
            There are also two useful SSE features absent with WebSockets that tipped the scale in favor of using SSE for Fjord: auto-reconnect, and native infrastructure compatibility.
          </p>
          <h4>3.3.2 Auto-reconnect</h4>
          
          <p>
            By default, SSE’s EventSource WebAPI automatically tries to reconnect the client to the server every time the client gets disconnected from the server. Because our use case involved streaming to drivers on mobile devices that may need to switch cell phone towers when driving across town, this seemed like a useful feature.
          </p>
          <figure>
            <img src="assets/media/gifs/sse_autoreconnect.gif" class="case-study-image" />
          </figure>          <p>
            The auto-reconnect feature also proved useful for auto-scaling purposes. Because, as we’ll explore later, the URL that clients are connected to is actually that of a load balancer, this meant that whenever a server has either crashed or needs to be shut down because of low activity, all of the clients currently receiving data from that server would automatically be reconnected to another existing server. 
            There was no need for us to configure any additional logic to handle that.
          </p>
          <p>
            The auto-reconnect feature worked in perfect tandem with the load balancer to persist client-server connections.
          </p>
          <h4>3.3.3 Native Infrastructure Compatibility</h4>
          <p>
            Lastly, the main advantage of SSE has to do with the fact that it works over the standard HTTP protocol and not a more specialized protocol like WebSockets. This means that SSE works right out of the box with all your infrastructure components like load balancers, proxies, etc.
          </p>
          <p>
            Configuring your infrastructure to work with WebSockets is of course possible, but it would require using additional libraries and spending more time around configurations.
          </p>
          <p>
            For all these reasons, we used SSE to stream records from our server to clients.
          </p>
          <figure>
            <img src="assets/media/images/WS vs SSE reworked.svg" class="case-study-image" />
          </figure>
          <p>
            Next, let’s understand why we decided to specifically build an API proxy for Kafka.
          </p>
          <!-- Section 4 -->
          <h2 id="section-4" class="h2">4. What is Kafka?</h2>
          <p>
            In this section, we will explore Kafka's role as an event streaming platform, why it often serves as the backbone of an organization’s infrastructure, and finally why it's a great conveyor of real-time data.
          </p>

          <h3 id="section-4-1">4.1 The evolution that led to Kafka</h3>
          
          <h4>4.1.1 EDA as Messaging Pattern for Microservices</h4>
          <p>
            An event driven architecture (EDA) offers a paradigm that decouples the production and consumption of messages (or events) in order to facilitate inter-microservices communication.
          </p>
          <figure>
            <img src="assets/media/gifs/producer_consumer.gif" class="case-study-image" />
          </figure>
          <p>
            By adding a broker in between the microservices that generate events (“producers”) and the microservices that receive events (“consumers”), an EDA allows microservices to communicate with each other without even being aware of each other’s existence.
          </p>
          <p>
            The three main architectural pieces of EDAs therefore include:
          </p>
          <ol>
            <li><strong>Producers</strong> that generate and send events to a broker,
            </li>
            <li>The routing of events through a <strong>Broker</strong> that acts as a middleware, and
            </li>
            <li><strong>Consumers</strong> that have access to any data they need from the broker.
            </li>
          </ol>
          
          <p>
            At the core of EDAs are <strong>events</strong>. An event is any significant occurrence or change in state for a distributed system. An event contains both a payload describing the systemic change or action that occurred, as well as a timestamp of when it occurred.
          </p>
          
          <figure>
            <img src="assets/media/images/json.png" class="case-study-image" />
          </figure>

          <p>
            Producers create and send events to the same broker, and then move on with their own business logic process, completely unaware of what happens to the event afterward.
          </p>
          <figure>
            <img src="assets/media/images/edaServices.png" class="case-study-image" />
          </figure>

          <p>
            All consumers that are interested in this particular event can then read it from the broker. For example, the inventory, billings, and delivery services could all react to the same order event. Events are immutable (i.e. they cannot be edited), but they may expire or be deleted.
          </p>
          <h4>4.1.2 Limitations of Traditional EDAs</h4>
          <p>
            Traditional EDAs simplify communication between microservices and are typically based on a message queue model. However, they also present a new set of challenges.
          </p>
          <p>
            In the traditional EDA model, the broker wears many hats. It has to:
          </p>
          <ol>
            <li>Push events to each appropriate consumer interested in that event,
            </li>
            <li>Keep track of which event was last consumed by each consumer (the “offset” or index), and this for all consumers, and
            </li>
            <li>Delete each event as soon as it is read by the appropriate consumer.
            </li>
          </ol>
          <p>
            The broker’s workload therefore grows in proportion to the number of consumers and events it must service. More events mean more work and more time is required for the broker to process the events.
          </p>

          <h4>4.1.3 Event Streaming</h4>
          <p>
            To handle an extremely high flow of events, event streaming platforms were born. They are still considered a subset of EDAs because they have the same three components of producers, consumers, and a middleware broker. However, they are designed to handle a higher velocity of events than traditional EDAs.
          </p>

          <figure>
            <img src="assets/media/images/eda vs event streaming.png" class="case-study-image" />
          </figure>

          <p>
            The main paradigm shift and key differentiating factor behind event streaming platforms is that the broker actually does <em>less</em> work than it does in the traditional EDA model.
          </p>
          <p>
            Instead of the broker pushing events to all consumers, each consumer is responsible for pulling each record from the broker. The broker similarly does not have to worry about keeping track of the offset of each consumer, since each consumer handles their own offset themselves.
          </p>
          <p>
            Finally, the broker does not have to delete events. While traditional EDA technologies use a <strong>queue-based</strong> structure, where events are deleted after they’re consumed, event streaming platforms use a <strong>log-based</strong> structure to durably store events.
          </p>
          <figure>
            <img src="assets/media/gifs/kafka.gif" class="case-study-image" />
          </figure>
          <p>
            With event streaming, newly added consumers can not only pick up newly received events, but they can also start to stream records from the very beginning of the log’s creation. This is, of course, only possible because events are not deleted after they are read.
          </p>
          <p>
            In order to ensure a scalable event streaming platform, where we place more business logic becomes significant. With traditional EDA technologies, the broker holds the bulk of the integration logic. Consumers just receive whatever is sent to them by the broker. 
            This sets up the <em>“Smart Broker, Dumb Consumer”</em> approach.
          </p>
          <p>
            In contrast, event streaming platforms opt for the <em>“Dumb Broker, Smart Consumer”</em> approach, placing more integration logic on each consumer instead. This enables a high volume and velocity of events, because there’s a significantly lower relationship between the number of events and consumers on the one hand, and the amount of work the broker needs to do on the other.
          </p>
          <p>
            In other words, increasing either the pace of events that are entering the system, or the number of consumers reading from the 
            broker, has a much less noticeable impact on the additional work the broker needs to do.
          </p>
          <p>
            This finally leads us to our next point, the gold standard in event-streaming platforms: Apache Kafka.
          </p>
          <h3 id="section-4-2">4.2 The rise of Apache Kafka</h3>
          <p>
            If data is the lifeblood of an organization, then Apache Kafka is like the organization’s circulatory system. Kafka offers a powerful, scalable, efficient, and redundant infrastructure that allows your distributed services to communicate with each other in real-time.
          </p>
          <figure>
            <img src="assets/media/images/kafka-logo.png" class="case-study-image" />
          </figure>
          <p>
            The technology was created at LinkedIn out of a need to track vast numbers of site events like page views and user actions, as well as to aggregate large quantities of logs from disparate sources within its distributed architecture. It later became an open source project of the Apache Foundation in 2011.
          </p>
          <p>
            Kafka was designed to be used to manage machine to machine communication. Kafka’s custom <strong>binary protocol</strong> over TCP is built to take advantage of advanced TCP features (e.g., the ability to multiplex requests and the ability to simultaneously poll any connections). 
          </p>
          <p>
            Kafka is optimized to handle extremely high throughput of messages. Back in 2019, LinkedIn was already processing <strong>7 trillion</strong> messages per day on their Kafka clusters. This is probably much higher today.
          </p>
          <p>
            Today, over <strong>80% of all Fortune 100</strong> companies use Kafka.
          </p>
          <figure>
            <img src="assets/media/images/brandsUsingKafka.png" class="case-study-image" />
          </figure>

          <h3 id="section-4-3">4.3 Kafka, Real-time, and SuperEats</h3>
          <p>
            A company like SuperEats can use Kafka to set up an infrastructure that can scale as the business grows, without worrying about performance issues down the line.
          </p>
          <figure>
            <img src="assets/media/gifs/supereats.gif" class="case-study-image" />
          </figure>
          <p>
            Kafka’s high throughput capacity makes it an ideal candidate to serve real-time events to end users. Kafka is also able to segregate streams of data into any number of topics, which themselves are further divided into multiple partitions. Each partition can have replicas on different brokers, which ensures redundancy in case a broker fails.
          </p>
          <p>
            Kafka provides yet another useful component not found in all event streaming platforms--a <strong>key</strong>. Kafka records have both a payload and a timestamp just like typical EDA events do. However, the payload of a Kafka record is itself comprised of two components:  a key and a value. The record <strong>value</strong> holds the actual business data. But the record <strong>key</strong> can be a very useful tool to not only further segregate data, but to also ensure in-order delivery.
          </p>
          <p>
            SuperEats needs a way to segregate data streams by activity type (e.g. incoming order v.s. Driver GPS position), by restaurant, and by customer or driver. For example, SuperEats could have one topic be <span class="code-snippet">orders</span>, and another topic be <span class="code-snippet">driver GPS</span> information. 
          </p>
          <p>
            Within the <span class="code-snippet">order</span> topic, the <strong>key</strong> of all records should probably be some type of concatenation of three components: the restaurant's, the customer’s, and the order’s unique identifiers. Because Kafka stores all records of the same key on the same partition, this would ensure that all the information related to order 2235407 for Jane4022354 from restaurant 72544986 would be stored on the same partition, and read in-order.
          </p>
          <p>
            The <span class="code-snippet">order</span> topic’s record <strong>value</strong> would itself contain information regarding the status of the order, the contents of the order, the restaurant's address, the customer's address, etc.
          </p>
          <p>
            Within the <span class="code-snippet">driver GPS</span> topic, the <strong>key</strong> would probably be the driver’s unique identifier. The <strong>value</strong> would contain the actual GPS data.
          </p>
        
          <p>
            In the next section, we’ll dive deeper into why you need an API proxy if you want to allow clients to stream from a Kafka cluster.
          </p>

          <!-- Section 5 -->
          <h2 id="section-5" class="h2">5. Why need an API Proxy for Kafka?</h2>
          <h3 id="section-5-1">5.1 Protocol Interoperability Issue</h3>
          <p>
            Kafka is a robust event streaming platform great for handling high volumes of events flowing between a relatively manageable number of producers and consumers. It uses a proprietary binary protocol designed to facilitate machine to machine communication.
          </p>
          <figure>
            <img src="assets/media/gifs/transport_protocol.gif" class="case-study-image" />
          </figure>
          <p>
            However, internet facing end users use their mobile phones, laptops, tablets and desktops and use the HTTP/S protocol. 
            As we saw earlier, the choice here is to leverage SSE and receive a continuous stream of data without any additional effort from the end user. There is a <strong>clear mismatch</strong> between Kafka and the end-user's protocol of consuming streams of data.
          </p>
          <h3 id="section-5-2">5.2 Using an API Proxy as Middleware</h3>
          <p>
            An API proxy can be designed to tackle the challenges of moving Kafka data online for public consumption. An API proxy is generally a server that sits between your web application and a backend service. Developers can build web applications using the set of API endpoints without knowing anything about the back-end.
          </p>
          <figure>
            <img src="assets/media/gifs/api proxy.gif" class="case-study-image" />
          </figure>
          <p>
            By positioning an API proxy between Kafka and the web, the API proxy can pull data from Kafka over Kafka’s binary protocol, and can push that data to connected devices in real-time via SSE, which is delivered over the HTTP protocol.
          </p>
          <h3 id="section-5-3">5.3 Additional Benefits of an API Proxy</h3>
          <p>
            An API Proxy not only makes client-side streaming from Kafka possible, but it also provides some additional benefits.
          </p>
          
          <div>
            <ul class="chart">
              <li>
                <img src="assets/media/images/security_layer.png" class="icon" />
                Letting end users connect directly to Kafka would present some significant security risks. Using a proxy provides an additional layer of security in between end users and your Kafka cluster.
              </li>
              <li>
                <img src="assets/media/images/external_fanout.png" class="icon" />
                An API proxy allows you to fanout Kafka records to thousands of end users over HTTP, significantly reducing the number of direct connections to your Kafka cluster. Using a proxy also allows you to dynamically scale the servers up and down to respond to external user traffic.
              </li>
              <li>
                <img src="assets/media/images/customizable_api.png" class="icon" />
                Having an additional layer between Kafka and end users enables more customizations, so you can group various Kafka topics from different Kafka clusters into any number of API end-points with any custom names you want.
              </li>
              <li>
                <img src="assets/media/images/paas.png" class="icon" />
                This additional messaging layer allows you to offload the resource-intensive task of real-time streaming to an external infrastructure, so you can focus on value creation activities that are central to your business.
              </li>
            </ul>
          </div>
          
          <p>
            What are some existing solutions for this API proxy? Let’s look at that next.
          </p>
          <!-- Section 6 -->
          <h2 id="section-6" class="h2">6. Existing Solutions</h2>
          <h3 id="section-6-1">6.1 Paid Solutions</h3>
          <p>
            If SuperEats wanted to use an existing, paid solution, what options would there be?
          </p>
          <figure>
            <img src="assets/media/images/existingSolutions.png" class="case-study-image" />
          </figure>
          <p>
            Ably, PubNub and MigratoryData offer specialized services for Kafka. All of these companies offer feature-rich, highly scalable solutions. The main downside of these services is that you pay a high price for the convenience and ease of use, and you’re locked into their ecosystems.
          </p>
          <h3 id="section-6-2">6.2 DIY Approach</h3>
          <p>
            If you wish to go the Do-It-Yourself (DIY) route, you will find many open-source platforms and services to help you accomplish this goal.
          </p>
          <figure>
            <img src="assets/media/images/DIY.png" class="case-study-image" />
          </figure>
          <p>The downside to this approach is the time, energy and expertise it requires to connect everything together. Installing and connecting all the different components is a challenge in itself, not to mention deploying and maintaining this infrastructure.
          </p>
          <p>
            If you want to add scalability into the mix, you have to understand how these components handle load and how to effectively tweak them to meet your use case. This is not always a realistic approach for small to medium sized companies.
          </p>
          <h3 id="section-6-3">6.3 Fjord: the only open source, full-service solution</h3>
          <p>Fjord positions itself in between the paid services and the DIY approach.
          </p>
          <figure>
            <img src="assets/media/images/solutions_chart.png" class="case-study-image" />
          </figure>
          <p>
            Fjord is a real-time API Proxy for Kafka. 
          </p>
          <ul>
            <li>
              It is open-source, scalable, and simple to deploy to AWS.
            </li>
            <li>
              Fjord lets you have full and exclusive ownership of the data coming in and out of your Kafka clusters.
            </li>
            <li>
              We offer a minimal feature set and a simple developer experience so that you can easily add any additional features you want.
            </li>
          </ul>
          <p>As far as we know, Fjord is the only open-source platform that incorporates all the infrastructure pieces you need to deploy an API proxy for Kafka right out of the box.
          </p>
          <!-- Section 7 -->
          <h2 id="section-7" class="h2">7. Building Fjord</h2>
          <h3 id="section-7-1">7.1 Overview of Triangular Pattern</h3>

          <p>Let’s first look at a high-level view of how an organization like SuperEats would integrate Fjord into their infrastructure.</p>
          
          <figure>
            <img src="assets/media/gifs/triangular_pattern.gif" class="case-study-image" />
          </figure>

          <p>
            First, SuperEats drivers, customers, and any restaurants working with SuperEats would all connect to the SuperEats web servers on a mobile app or a browser via HTTP/S (e.g., to SuperEats.com).
          </p>

          <figure>
            <img src="assets/media/gifs/end_users_superEats.gif" class="case-study-image" />
          </figure>

          <p>
            These servers would deliver, via either a mobile app or a browser, a page that initiates an SSE connection with (i.e. receives push updates from) the Fjord cluster deployed on SuperEats’ AWS account.
          </p>

          <figure>
            <img src="assets/media/gifs/supereats_responds_sse.gif" class="case-study-image" />
          </figure>

          <p>
            Fjord, in turn, would pull records from SuperEats’ Kafka cluster, and deliver them to connected clients who are interested in particular API topics.
          </p>

          <figure>
            <img src="assets/media/gifs/pull_and_deliver.gif" class="case-study-image" />
          </figure>

          <p>
            It’s important to note that SuperEats drivers and customers are not aware that they are also receiving a data stream from Fjord. From their perspective, all they see is that they’re connected to the SuperEats domain or app.
          </p> 

          <p>
            This allows SuperEats to deliver customized content that has the look and feel of their own website, without having to deal with the additional streaming load on their servers.
          </p>

          <p>This structure is commonly referred to as the triangular pattern.</p>


          <h3 id="section-7-2">7.2 Design Goals</h3>
          <p>We designed Fjord with four main goals in mind:</p>
          <ul>
            <li><strong>API Proxy</strong>: open Kafka topics to client-side streaming,</li>
            <li><strong>Security</strong>: enable Fjord business users to restrict access to their Kafka stream through security parameters,</li>
            <li><strong>Scalability</strong>: create a scalable platform-as-a-service (PaaS) infrastructure, and</li>
            <li><strong>Ease of deployment</strong>: make deploying Fjord super simple.</li>
          </ul>
          <p>
            In the next section, we’ll walk through the evolution of how we built Fjord to achieve these design goals, and address some of the key decisions we made along the way.
          </p>
          
          <h3 id="section-7-3">7.3 The Evolution of Fjord</h3>
          <p>
            Fjord’s primary components are the server that maintains persistent SSE connections with clients, and the consumer that pulls data from Kafka and moves it to the server.
          </p>
          <figure>
            <img src="assets/media/gifs/decoupling 1.gif" class="case-study-image" />
          </figure>
          <h4>7.3.1 Setting up a real-time streaming server</h4>
          <p>
            Our first step was to build a server that could stream content in real-time to connected clients. To do this, we experimented with SSE and WebSockets, before settling on SSE for our particular use case. After configuring the server, we moved on to extracting data from Kafka.
          </p>

          <h4>7.3.2 Learning and Testing Kafka</h4>
          <p>
            Our next step was to simulate a business’s Kafka cluster itself, so that we could create a consumer that would be able to pull data from the cluster. We assembled a cluster with three brokers, first locally and then remotely, using a virtual private server (VPS).
          </p>
          <figure>
            <img src="assets/media/images/kafkajs.png" class="case-study-image" />
          </figure>
          <p>
            Because we planned to work with Node JS, we used a NodeJS client library called KafkaJS. KafkaJS is widely used, well tested, and has an active online and Slack community. This client library also allowed us to start with some default configurations for the consumer and adjust them as needed, and simulate records being produced into the cluster.</p>
          <h4>7.3.3 Accessing a Secure Kafka Cluster</h4>
          <p>
            Kafka is not secure by default, and it can durably store sensitive data. We knew we needed to implement some security measures for the cluster. We enabled a firewall for the VPS and whitelisted the producer and consumer so it could still reach the remote Kafka broker.</p>
            <figure>
              <img src="assets/media/images/secureKafka.png" class="case-study-image" />
            </figure>
          <p>
            Additionally, we implemented SASL authentication for all Kafka clients, meaning producers and consumers would need to provide a username and password to the broker before interacting with the cluster.
          </p>
          <p>
            One item to note is that we chose to work with SASL-PLAIN, which means our client credentials are not encrypted and could be intercepted as they are sent from the Kafka client to the cluster. In practice, SASL should only be used alongside some form of encryption, like TLS or GSSAPI. We assume that the business using Fjord would have TLS enabled, in which case setting up SASL-SSL is similar to enabling SASL-PLAIN, and relatively simple.
          </p>

          <h4>7.3.4 Expanding the Fjord Server with Kafka and JWT</h4>
          <p>
            At this point, Fjord consisted of a web server that was able to maintain SSE connections with web clients and a KafkaJS consumer that would push consumed records to our server. We were also able to interact with a secured Kafka cluster. We moved on to securing the front end of Fjord. To do this, we restricted access to the SSE stream using JSON Web Tokens (JWTs), which act as a way to represent claims between two parties over the internet.
          </p>
          <p>
            Using JWTs, a private key is used by the server to generate valid public keys and then verify that a given public key (i.e. a token) passed back to the server from the client is valid.
          </p>
          <video autoplay loop muted playsinline>
            <source src="./assets/media/mp4/JWT.mp4" type="video/mp4" />
            Your browser does not support the HTML5 Video element.
          </video>
          <p>
            Fjord leaves the option of using JWTs up to the business user, via some configuration settings.
          </p>
          <p>
            With a Fjord consumer able to interact with a secured Kafka cluster and a Fjord server able to securely stream data to SSE clients, the next challenge was making Fjord scalable and deploying it to the cloud.</p>

          <h4>7.3.5 Dockerizing components & Exploring AWS</h4>
          <p>
            After doing some initial exploration of the AWS Cloud Development Kit (CDK), and the options for deploying infrastructure on AWS, we knew we were probably going to use AWS’s Elastic Container Service (ECS) as it could let us achieve our scalability needs down the line.
          </p>
          <p>
            In order to use ECS, however, we needed to first containerize both the server and the consumer. For that, we used Docker. This allowed us to run multiple instances of each, with their proper dependencies.
          </p>
          <figure>
            <img src="assets/media/images/dockerizedConsumerServer.png" class="case-study-image" />
          </figure>
          <p>
            AWS ECS offers two launch types--EC2 and Fargate.
          </p>
          <figure>
            <img src="assets/media/images/ecsDockerized.png" class="case-study-image" />
          </figure>

          <p>
            With EC2, you get more control over your deployment, but you need to provision and manage the servers your containers are running on. With ECS and Fargate, AWS manages the containers and the underlying servers they’re run on.
          </p>
          <p>
            We decided to go with ECS and Fargate, so Fjord business users like SuperEats wouldn’t need to worry about provisioning the underlying servers that the Fjord components are running on.
          </p>

          <h4>7.3.6 Decoupling the Consumer and Server</h4>
          
          <p>
            At this point, the consumer needed to be aware of the IP and port on which the server is running, so that it can send POST requests with records to it. This works as long as there’s only one server instance.
          </p>
          <figure>
            <img src="assets/media/gifs/decoupling 1.gif" class="case-study-image" />
          </figure>
          <p>
            But the whole point of using ECS is to be able to scale, and have multiple servers as needed to handle more load. With the current setup, any newly deployed server would not receive records from the consumer.
          </p>
          <figure>
            <img src="assets/media/gifs/decoupling 2.gif" class="case-study-image" />
          </figure>
          <p>
            One approach could be to somehow have the consumer be aware of every newly deployed server, and then make a separate POST request to every server, for every received record from Kafka. 
          </p>
          <figure>
            <img src="assets/media/gifs/decoupling 3.gif" class="case-study-image" />
          </figure>
          <p>
            But this approach would put a lot of strain and pressure on the consumer, which is already working hard to keep up with the stream of records coming from Kafka.
          </p>
          <p>
            The solution we chose was to decouple the consumer from the server by using a middleware that would provide a publish-subscribe mechanism.
          </p>
          <figure>
            <img src="assets/media/gifs/decoupling 4.gif" class="case-study-image" />
          </figure>
          <p>
            We looked at a few different options for this middleware, including SNS and Redis.
          </p>

          <h4>7.3.7 SNS v.s. Redis</h4>

          <figure>
            <img src="assets/media/images/sns vs redis.png" class="case-study-image" />
          </figure>

          <p>
            One option was to use a publish subscribe model with an AWS messaging service, such as Simple Notification Service (SNS). SNS is a fully managed, publish subscribe messaging service that provides asynchronous message delivery from publishers to subscribers. While SNS is usually used to send data from a microservice to an end user via a text message or an email, it can also be placed between microservices to decouple their communication. SNS can fan out messages to multiple subscribers, which matched with our desire to get the records from one consumer to multiple instances of the server.
          </p> 
          <p>
            However, SNS is a more full-featured service that includes features like message filtering and durable storage of messages, which we did not require. SNS also requires some additional code on our server to handle the initial subscription to an SNS topic as well as logic to handle unsubscribing clients as they close the connection to the server. 
          </p>
          <p>
            Another interesting service was Redis and AWS’s Elasticache for Redis. While Redis is usually used as a caching layer, it also has publish and subscribe functionality. In this architectural pattern, one Redis client can publish to a particular channel on the Redis server, and any number of additional Redis clients can subscribe to that channel. 
          </p>
          <p>
            AWS Elasticache is built to work seamlessly with Redis, which meant that after we configured our consumer to publish to a Redis channel and configured our server to subscribe to the Redis channel, no additional changes needed to be made for Fjord to work in the AWS ecosystem. 
          </p>
          <p>
            After comparing SNS and Redis, we decided AWS Elasticache and Redis would be a perfect fit for Fjord. Redis is extremely fast, lightweight, and required minimal code changes to the consumer and server.
          </p>

          <h4>7.3.8 Facilitating Deployments: the AWS CDK and Fjord CLI</h4>
          <p>
            Our final design goal was to make Fjord simple to deploy. To facilitate the ECS cluster that the server and consumer live in as well as the Elasticache cluster, more than 40 AWS resources are required, including a virtual private cloud (VPC), security groups, subnets, NAT gateways, an application load balancer, and many others. 
          </p>

          <figure>
            <img src="assets/media/images/aws_console.png" class="case-study-image" />
          </figure>

          <p>
            It’s possible to manually deploy each resource on the AWS Console, which is the web UI developers can interact with by clicking and specifying configurations. However, this is error-prone and not a repeatable, feasible way to deploy infrastructure on AWS, especially when one of the key design goals of Fjord is to make deployment simple. 
          </p>

          <p>
            AWS CloudFormation allows a developer to model and set up AWS resources by creating a template that describes all AWS resources. Under the hood, AWS takes care of actually deploying and managing the state of all these resources. 
          </p>
          <p>
            One simple way to interact with CloudFormation is to use the AWS Cloud Development Kit (CDK), which allows a developer to write code in a number of their favorite languages that will eventually be translated to a CloudFormation template. We decided to go with the AWS CDK, which makes it as simple as running a few AWS CDK commands to setup, deploy, and tear down all AWS resources.
          </p>
          <p>
            With the AWS CDK deployment code written, Fjord was now a scalable, secure, PaaS.
          </p>
          <p>
            But we were not done yet. Using the CDK is still a relatively cumbersome process, with lots of mostly irrelevant outputs to the console.
          </p>
          <p>
            Our final task was building a Command Line Interface (CLI) on top of the CDK. We designed this CLI to abstract away much of the underlying process, and provide a more streamlined and enjoyable user experience. You can learn more about this in section 8.
          </p>

          <h3 id="section-7-4">7.4 Fjord's Architecture</h3>
          <p>
            The fully detailed architecture diagram of a deployed Fjord cluster looks like this.
          </p>
          <img class="lazy" data-src="./assets/media/gifs/full_flow.gif"/>

          <ol>
          <li>
            Clients, seen here in the yellow area, connect to Fjord via a <strong>load balancer</strong>.
          </li>
          <li>
            The load balancer connects each client to the most available <strong>server</strong>. These servers are in ECS and managed by Fargate, and automatically scale to accommodate more or less traffic.
          </li>
          <li>
            On the other end of the process, <strong>consumers</strong> are receiving data from the business user’s Kafka cluster. This traffic is routed through a <strong>NAT Gateway</strong> for added security, so that only the responses to requests from the consumers can come into the system.
          </li>
          <li>
            Finally, sitting in between the servers and the consumers is the <strong>Redis pub-sub</strong> server. This allows servers to automatically subscribe to all the content being published by all the consumers, and decouples their interaction.
          </li>
          </ol>
          <p>
            How does all this infrastructure get deployed to AWS? Let's look at that next.
          </p>
          
          <!-- Section 8 -->
          <h2 id="section-8" class="h2">8. Deploying & Using Fjord</h2>
          <p>
            There are four steps to using Fjord.
          </p>
          <ol>
            <li>
              Installing & Using the Fjord Command Line Interface (CLI)
            </li>
            <li>
              Customizing your infrastructure components
              
            </li>
            <li>
              Deploying the Fjord architecture on AWS using the CLI
            </li>
            <li>
              Integrating your client-side code to work with the Fjord architecture
            </li>
          </ol>
          <h3 id="section-8-1">8.1 The Fjord CLI</h3>
          
          <p>
            To deploy Fjord, it’s necessary to globally install the <span class="code-snippet">fjord_cli</span> npm package, which provides a thin 
            wrapper over the AWS CDK with a few simple commands.
          </p>
          <figure>
            <img src="assets/media/images/fjord install.png" class="case-study-image" />
          </figure>
          <p>
            After doing this, create and navigate into a new directory you wish to use for your new deployment.
          </p>
      
          <h3 id="section-8-2">8.2 Customizing your infrastructure components</h3>
            In your directory, use the command <span class="code-snippet">fjord setup</span>. This will generate a <span class="code-snippet">FjordSettings.json</span> file.
          </p>
          <figure>
            <img src="assets/media/images/FjordSettings.png" class="case-study-image" />
          </figure>
          <p>
            This is where the business user’s configuration details live. This includes the name of your application, an optional JWT private key, the names of the Kafka topics you wish to pull records from, and the names of the topics you want to expose in client side code.
          </p>
          <p>Additionally, all consumer groups should be specified in this file, as an array of objects that each contain the configurations like the name of the Kafka consumer group to which it belongs, and any details necessary to access the Kafka cluster (e.g. Broker IP addresses, security information, etc).
          </p>
          <h3 id="section-8-3">8.3 Deploying Fjord to AWS</h3>
          <figure>
            <img src="assets/media/gifs/fjordCLI.gif" class="cli"/>
          </figure>
          <p>After you’ve edited the settings file, run <span class="code-snippet">fjord deploy</span>. This will provision and create more than 40 AWS resources needed for Fjord’s infrastructure and provide you with IP addresses for your NAT Gateways and the Load Balancer URL.
          </p>
          <p>If the business user has a firewall for the Kafka cluster, they’ll need to whitelist the IP address of the NAT gateways to ensure the Fjord Consumer is able to access the Kafka cluster.
          </p>
          <h3 id="section-8-4">8.4 Client-side Integration</h3>
          <p>
            To interact with Kafka from an HTML page or a mobile application, the business user will need to integrate their client-side code with Fjord. To do this, just a handful of lines of code will need to be added to their existing client-side code.
          </p>
          <figure>
            <img src="assets/media/images/darker client code.png" class="case-study-image" />
          </figure>
          <p>
            The load balancer's URL that was output when Fjord was deployed needs to be used to establish a SSE connection using the EventSource API for browsers or a similar web API for Android or iOS mobile apps. A topic and userId also need to be specified, along with an optional JWT token, if the business user has configured their Fjord infrastructure to use JWTs.
          </p>
          <p>
            Finally, the front end developer can write the body of a callback function passed to the <span class="code-snippet">onmessage</span>  method, which will be executed each time a new record is received by Fjord.
          </p>
          <p>
            Each incoming record should be parsed from a text to a simple JavaScript object, which can then be incorporated into the page however the front end developer wants--whether as an additional row in a table, a data point on a graph, etc.
          </p>
          <!-- Section 9 -->
          <h2 id="section-9" class="h2">9. Technical Challenges</h2>
          <h3 id="section-9-1">9.1 Auto-scaling and Load Balancing</h3>
          <h4>9.1.1 What should auto-scale?</h4>
          <p>
            With Fjord deployed on ECS with Fargate, Fjord was ready-to-scale. Deciding which aspects should be automatically scaled, and which should be manually scaled, was the first challenge.
          </p>
          <figure>
            <img src="assets/media/images/consumerGroups.png" class="case-study-image" />
          </figure>
          <p>
            Kafka’s smart consumer groups are Kafka’s native mechanism for implementing horizontal scaling. Kafka allows multiple members in the same consumer group to split the workload of reading from the same topic, each member reading from a different partition. Because the business user has the ability to specify any number of members within each consumer group when deploying Fjord, we thought this manual mechanism would allow Fjord to take advantage of Kafka’s native scaling capabilities. We decided that the consumer tasks should therefore not be auto-scaled, as we did not want ECS alarms to conflict with Kafka.
          </p>
          <p>
            However, we decided to focus our auto-scaling efforts on the server. The servers could be scaled up and down depending on several different metrics, or what AWS calls alarms.
          </p>
          <h4>9.1.2 Auto-scaling alarms</h4>
          <p>
            To set up scaling for the server, it was necessary to configure CloudWatch alarms that would trigger when a server instance met a certain threshold of a given metric. AWS Auto-Scaling Groups could then be used to spin up (or down) an instance of the server. Metrics like CPU, RAM, and number of client connections could all be used to set scaling policies.
          </p>
          <p>
            Fjord employs autoscaling policies based on the memory and CPU usage of each instance of the server. Whichever reaches a pre-established threshold of percentage usage will trigger a new instance of the server to be spun up.
          </p>
          <p>
            Using auto-scaling policies based on memory and CPU allows the server to scale horizontally in response to either the number of front-end connections with clients that the server is handling, or based on the number of records the server is receiving from the Kafka consumers, since distributing each record to all clients requires more CPU usage.
          </p>
          <h4>9.1.3 Load Balancer Algorithm</h4>
          <p>
            By default, the AWS Application Load Balancer (ALB) uses a round robin algorithm to distribute traffic across all the available servers. This is not an optimal algorithm for our use case, because it could result in an uneven distribution of clients on the servers, as it doesn’t take into account the fact that some client connections may have closed.
          </p>
          <p>
            With a round robin algorithm, if one server has only 10 clients and another has 8000, they would still be 
            receiving the same number of new requests.
          </p>
          <p>
            To better distribute traffic by taking into account each server’s current workload, we reconfigured the ALB to use a Least Outstanding Requests (LOR) algorithm.
          </p>
          <h3 id="section-9-2">9.2 CORS Issue & Heartbeat</h3>
          <h4>9.2.1 Cross-Origin Requests</h4>
          <p>
            A cross-origin request occurs when a page requests access to a resource from a different origin than itself. By default, browsers don’t allow this to happen, as a security measure. By using special request headers, you can explicitly enable Cross-Origin Resource Sharing (or CORS) to allow this to happen.
          </p>
          <p>
            In our SuperEats example, the SuperEats web servers are delivering an HTML page that makes a request for the Fjord stream. The HTML page is on the SuperEats domain, which is different from the Fjord domain on AWS. For that reason, we knew we’d need to implement CORS. We used the CORS library for Express, since our server is built in Nodejs.
          </p>
          <p>
            Everything was working fine locally, but we started experiencing some issues when we deployed our code to AWS.
          </p>
          <h4>9.2.2 CORS Issue in Production</h4>
          <p>
            We noticed that after a brief period of inactivity, when there were no records streaming, clients would get a CORS error displayed on the browser console, and stopped receiving any records.
          </p>
          <figure>
            <img src="assets/media/gifs/cors.gif" class="case-study-image" />
          </figure>
          <p>
            Things were fine as long as we were regularly streaming records. But once the records stopped for a brief period of time, we’d get a CORS error, and no longer be able to stream even after the records resumed streaming. This was happening despite the fact that we had explicitly enabled CORS via the proper headers.
          </p>
          <p>
            The issue was that after a period of not receiving any more records, the load balancer would timeout the HTTP responses, thereby forgetting about the headers that had enabled CORS in the first place. 
            So that’s why we’d get that CORS error.
          </p>
          <h4>9.2.3 Solution: Heartbeat</h4>
          <p>
            The solution to this production-specific issue dealing with the load balancer was to implement what’s known as a heartbeat or “pulse” for SSE.
          </p>
          <figure>
            <img src="assets/media/gifs/heartbeat.gif" class="case-study-image" />
          </figure>
          <p>
            At a regular interval, about every 30 seconds by default, we send a blank message to all the clients connected to each server. The client doesn’t see this blank message appear anywhere, which is great, but the heartbeat is useful for two main reasons.
          </p>
          <p>
            First, this checks whether any client has closed the connection since the last time we sent an actual record (and also closes the connection on the server-side if that’s the case). Most importantly for us, this also lets the load balancer know that the connection is still ongoing.
          </p>
          <p>Once we implemented the SSE heartbeat, we no longer had any CORS issues.
          </p>
          <h3 id="section-9-3">9.3 Load Testing Fjord</h3>
          <p>
            There are two opening points in the Fjord architecture. First, the Fjord consumer pulls in streams of Kafka data from the business’s Kafka cluster. Second, the Fjord server pushes Kafka data to end users in the browser. While we did perform some stress testing on how many records Fjord could handle per second, we decided this was not the primary point to test. We built Fjord with the intent to stream information that’s usable for connected clients--a maximum dictated by the limits of human perception to a relatively low number. We assume the streaming data the business wants to deliver is about ten messages per second, which the Fjord consumer and Elasticache for Redis are able to handle easily.
          </p>
          <p>
            The second opening point into Fjord is the load balancer that sits in front of the scalable layer of servers that maintain SSE connections with clients. As business users may want to stream data to thousands or tens of thousands of customers and contract employees with traffic varying immensely depending on the time of day, the Fjord server needs to be able to handle bursty traffic, with some down periods and some periods with vast amounts of traffic.  
          </p>
          <p>
            With our use case in mind, we focused load testing on the frontend of the system--the number of connections the Fjord server could maintain simultaneously.
          </p>
          <p>
            When searching for a load testing tool, we first had a hard time finding an open-source library that worked with Server-Sent-Events. There were several options for load testing Websockets, like Artillery and Siege, but not as many options for SSE.
          </p>
          <figure>
            <img src="assets/media/images/testingSSE.png" class="case-study-image" />
          </figure>
          <p>
            We eventually came across Gatling, which actually had some good docs for testing SSE. Gatling is built on top of Java and Scala, which did entail learning and working with some Scala. We used Gatling to test what load an individual server could handle.
          </p>
          <figure>
            <img src="assets/media/images/8000_connections.png" class="case-study-image" />
          </figure>
          <p>
            We found that before scaling out, a single server can hold SSE connections for up to 8,500 simultaneous requests. 
            Fjord servers use the minimal CPU and memory offered by AWS as a cost savings measure for the business user, to ensure that spend is limited to how much use the system is seeing, and no more than that. 
          </p>
          <p>
            Rather than trying to vertically scale an individual Fjord server that would maintain a larger number of SSE connections, we simply had the AWS autoscaling policy spin up or down new instances as needed.  
          </p>
          <!-- Section 10 -->
          <h2 id="section-10" class="h2">10. Future Work</h2>
          <p>
            Fjord is an evolving open source project, with the potential for additional features in the future. We see a few particular improvements and optimizations we’d like to make with Fjord.
          </p>
          <h3 id="section-10-1">10.1 More Advanced Security Features</h3>
          <p>
            The Fjord consumer currently connects to a business’s Kafka cluster using a SASL-plain username and password. Kafka offers more advanced security features, including encrypting communication using SSL, making use of network access control lists, and encrypting data at rest, and it would be ideal for Fjord to integrate with more of Kafka’s security options.
          </p>
          <h3 id="section-10-2">10.2 Bidirectional Communication</h3>
          <p>
            Fjord is designed with one-way, server push streaming in mind. While this setup is a perfect fit for our use case, we could see the appeal of a bidirectional flow of events.
          </p>
          <p>
            With tighter Kafka security accomplished with point 10.1 above, we would feel better about allowing the business user to also inject events into their Kafka stream based on client actions.
          </p>
          <p>
            This could be done with either WebSockets or SSE over HTTP2.
          </p>
          <p>
            To allow this to happen, we would need a similar architecture to the process of consuming records from Kafka, but reversed. Once the servers receive data from the clients, they would then be publishers to the Redis pubsub middleware. We would need another service deployed on ECS with Fargate, this time to be producers to a Kafka cluster.
          </p>
          <p>
            Each producer would subscribe to the Redis pubsub, and push every received record to Kafka. We could allow the business user to customize how many producers they want, perhaps based on some type of key added to the record by either the server or the front-end.
          </p>
        </div>
      </div>
    </div>

    <div id="presentation" class="main-section">
      <div class="bg-gray">
        <h2>Presentation</h2>
        
        <iframe
          src="https://www.youtube-nocookie.com/embed/-ax_du3voYc?rel=0&controls=1"
          title="YouTube video player"
          frameborder="0"
          allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
          allowfullscreen
        ></iframe>
      </div>
    </div>

    <div id="our-team" class="main-section">
      <div>
        <div>
          <div>
            <h2>Meet our team</h2>
            <p class="text-xl text-gray-300">
              We are currently looking for opportunities. If you liked what you
              saw and want to talk more, please reach out!
            </p>
          </div>
          <ul class="people">
            <li class="profile">
              <img
                class="mx-auto h-40 w-40 rounded-full xl:w-56 xl:h-56 lazy"
                data-src="assets/team/austin.jpeg"
                alt=""
              />
              <div>
                <div>
                  <h3>Austin James Miller</h3>
                  <p>Denver, CO</p>
                </div>

                <ul class="social">
                  <li>
                    <a href="mailto:milleraustin303@gmail.com" target="_blank"
                      ><i class="fas fa-envelope"></i
                    ></a>
                  </li>
                  <li>
                    <a
                      href="https://www.linkedin.com/in/aumi9292"
                      target="_blank"
                      ><i class="fab fa-linkedin"></i
                    ></a>
                  </li>
                  <li>
                    <a href="https://github.com/aumi9292" target="_blank"
                      ><i class="fab fa-github"></i
                    ></a>
                  </li>
                  <li>
                    <a href="https://aumi.dev" target="_blank"
                      ><i class="fas fa-globe"></i
                    ></a>
                  </li>
                </ul>
              </div>
            </li>

            <li class="profile">
              <img
                class="mx-auto h-40 w-40 rounded-full xl:w-56 xl:h-56 lazy"
                data-src="assets/team/leena.jpeg"
                alt=""
              />
              <div>
                <div>
                  <h3>Leena Lallmon</h3>
                  <p>Montreal, Que</p>
                </div>

                <ul class="social">
                  <li>
                    <a href="mailto:leena.lallmon@gmail.com" target="_blank"
                      ><i class="fas fa-envelope"></i
                    ></a>
                  </li>
                  <li>
                    <a
                      href="https://www.linkedin.com/in/leenalallmon/"
                      target="_blank"
                      ><i class="fab fa-linkedin"></i
                    ></a>
                  </li>
                  <li>
                    <a href="https://github.com/leena" target="_blank"
                      ><i class="fab fa-github"></i
                    ></a>
                  </li>
                  <li>
                    <a href="https://leenalallmon.com" target="_blank"
                      ><i class="fas fa-globe"></i
                    ></a>
                  </li>
                </ul>
              </div>
            </li>

            <li class="profile">
              <img
                class="mx-auto h-40 w-40 rounded-full xl:w-56 xl:h-56 lazy"
                data-src="assets/team/sophie.jpeg"
                alt=""
              />
              <div>
                <div>
                  <h3>Sophie Chan</h3>
                  <p>Toronto, Ont</p>
                </div>

                <ul class="social">
                  <li>
                    <a href="mailto:hello@sophiec.dev" target="_blank"
                      ><i class="fas fa-envelope"></i
                    ></a>
                  </li>
                  <li>
                    <a
                      href="https://www.linkedin.com/in/sophiecwy"
                      target="_blank"
                      ><i class="fab fa-linkedin"></i
                    ></a>
                  </li>
                  <li>
                    <a href="https://github.com/J-SophieCodes" target="_blank"
                      ><i class="fab fa-github"></i
                    ></a>
                  </li>
                  <li>
                    <a href="https://sophiec.dev" target="_blank"
                      ><i class="fas fa-globe"></i
                    ></a>
                  </li>
                </ul>
              </div>
            </li>

            <li class="profile">
              <img
                class="mx-auto h-40 w-40 rounded-full xl:w-56 xl:h-56 lazy"
                data-src="assets/team/vahid.jpeg"
                alt=""
              />
              <div>
                <div>
                  <h3>Vahid Dejwakh</h3>
                  <p>Hampton, VA</p>
                </div>

                <ul class="social">
                  <li>
                    <a href="https://vahid.blog/#contact" target="_blank"
                      ><i class="fas fa-envelope"></i></a>
                  </li>
                  <li>
                    <a
                      href="https://www.linkedin.com/in/vahiddejwakh"
                      target="_blank"
                      ><i class="fab fa-linkedin"></i
                    ></a>
                  </li>
                  <li>
                    <a href="https://github.com/dejwakh" target="_blank"
                      ><i class="fab fa-github"></i
                    ></a>
                  </li>
                  <li>
                    <a href="https://vahid.blog" target="_blank"
                      ><i class="fas fa-globe"></i
                    ></a>
                  </li>
                </ul>
              </div>
            </li>
          </ul>
        </div>
      </div>
    </div>

    <script src="javascripts/script.js"></script>
  </body>
</html>
